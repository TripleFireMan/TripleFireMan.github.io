{"posts":[{"title":"CAReplicatorLayer探究","text":"概述 这个layer干什么用的？ 这个layer如何用？ 何种场景适合这个layer发挥？ 带着这些问题，我们上路，开始研究它。 苹果官方demo ​ 这个是我搜到的苹果对CAReplicatorLayer讲述功能时，使用到的demo，有没有吊炸天的感觉，但是实际上，我要告诉你的是，实现这样一个功能使用的代码不超过300行。 干什么用？​ 说实话，其实这个layer很偏门，基本上很少有人会用到它，它的主要作用是用来复制任意数量的它的sublayer的，sublayer是它复制的源头，如果没有sublayer那么是复制不了的。复制的方式，可能是几何变换、时间控制、颜色变换。 ​ 使用CAReplicatorLayer对象可以通过一个图片源构建复杂的布局，而仅仅是通过坐标转换、颜色转换、时间转换。 如何使用 基础使用 多说无益，看代码吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (CAReplicatorLayer *)xReplicatorLayer{ // 创建原始图层，白色的大小 50，50 CALayer *redLayer = [CALayer layer]; redLayer.backgroundColor = [[UIColor whiteColor]CGColor]; redLayer.frame = CGRectMake(0, 0, 50, 50); // 创建复制图层，并设置复制5个，复制转换为按横坐标偏移60，颜色为从白变为红 CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer]; replicatorLayer.instanceCount = 5; replicatorLayer.instanceTransform = CATransform3DMakeTranslation(60, 0, 0); CGFloat step = - 1 / 5.f; replicatorLayer.instanceGreenOffset = step; replicatorLayer.instanceBlueOffset = step; [replicatorLayer addSublayer:redLayer]; return replicatorLayer;}- (CAReplicatorLayer *)ReplicatorLayer{ // 获取经过X轴变换的layer CAReplicatorLayer *redLayer = [self xReplicatorLayer]; // 做纵坐标变换，复制6次，变换方式为向上偏移60，颜色从红变灰 CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer]; replicatorLayer.instanceCount = 6; replicatorLayer.instanceTransform = CATransform3DMakeTranslation(0, 60, 0); CGFloat step = -1 / 6.f; replicatorLayer.instanceRedOffset = step; [replicatorLayer addSublayer:redLayer]; return replicatorLayer;}- (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor blackColor]; CAReplicatorLayer *replicatorLayer = [self ReplicatorLayer]; replicatorLayer.frame = CGRectMake(10, 100, 50, 50); [self.view.layer addSublayer:replicatorLayer]; } 实现效果，如下图 除了做横纵坐标变换以外，还可以做旋转，代码如下 1234567891011121314151617- (CAReplicatorLayer *)rotateReplicatorLayer{ CAReplicatorLayer *layer = [CAReplicatorLayer layer]; layer.frame = CGRectMake(screen_width() / 2, screen_height() / 2, w_16, h_16); CALayer *content = [CALayer layer]; content.opacity = 1; content.frame = layer.bounds; content.contents = (id)[[UIImage imageNamed:@&quot;brightBlob.png&quot;]CGImage]; layer.instanceCount = 36; layer.instanceColor = [[UIColor redColor]CGColor]; CATransform3D transform = CATransform3DMakeTranslation(16, 0, 0); layer.instanceTransform = CATransform3DRotate(transform, -M_PI * 10 / 180, 0, 0, 1); [layer addSublayer:content]; return layer;} 效果图如下 进阶使用 使用该类可以实现粒子发射器的效果，结合动画的使用，加上旋转、位移变换，可以实现类似游戏中的粒子发射器的效果。此处需要定义一个CYEmitterLayer类，该类要继承自CAReplicatorLayer。很显然，我要对CAReplicatorLayer进行功能扩展。让它具备开始发射粒子和停止发射粒子的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#import &lt;QuartzCore/QuartzCore.h&gt;@interface CYEmitterLayer : CAReplicatorLayer{}@property (nonatomic, strong) CALayer *imageLayer; //作为原始层，供CAReplicatorLayer 复制@property (nonatomic, assign) CGFloat rotator; //旋转因子，实现旋转功能@property (nonatomic, assign) CGFloat length; //发射长度@property (nonatomic, assign) CGFloat count; //一次发射的个数@property (nonatomic, assign) CGFloat angle; //发射角度@property (nonatomic, assign) CGFloat cycleTime; //循环时间@property (nonatomic, assign) CGFloat xAdjust; //x轴调整@property (nonatomic, assign) CGFloat yAdjust; //y轴调整- (void)start;- (void)stop;@end #import &quot;CYEmitterLayer.h&quot;#import &lt;UIKit/UIKit.h&gt;@implementation CYEmitterLayer- (id)init{ self = [super init]; if (self) { self.count = 1; self.imageLayer = [CALayer layer]; self.imageLayer.contents = (id)[UIImage imageNamed:@&quot;brightBlob&quot;].CGImage; self.instanceColor = [[UIColor whiteColor]CGColor]; [self addSublayer:self.imageLayer]; } return self;}- (void)start{ // 配置发射信息 self.imageLayer.frame = self.bounds; self.imageLayer.opacity = 1.0f; self.instanceCount = self.count; self.instanceDelay = self.cycleTime / self.count; // 校准粒子与上个粒子之间的角度以及位置 CATransform3D transform = CATransform3DMakeRotation(self.rotator, 0, 0, 1); self.instanceTransform = CATransform3DTranslate(transform, self.xAdjust, self.yAdjust, 0); // 校准发射源发射角度 self.transform = CATransform3DMakeRotation(self.angle, 0, 0, 1); // 执行动画，实现发射效果 [self animation];}- (void)animation{ CGPoint newPoint = CGPointMake(0, self.length); CABasicAnimation *basic = [CABasicAnimation animation]; basic.keyPath = @&quot;position&quot;; basic.toValue = [NSValue valueWithCGPoint:newPoint]; basic.duration = self.cycleTime; basic.repeatCount = MAXFLOAT; [self.imageLayer addAnimation:basic forKey:@&quot;position&quot;];}- (void)stop{ self.imageLayer.opacity = 0; [self.imageLayer removeAllAnimations]; self.instanceCount = 0;}@end 这里是头文件的定义，我们扩展了动画执行时间、发射个数、发射角度、粒子旋转角度等基本属性，通过对这些基本属性的合理赋值，就可以实现发射粒子的功能了。我这里只写了俩个简单的用法，具体怎么实现更牛逼，更吊的效果就靠看官脑洞大开了。 效果图如下 ​ 何时使用？​ 我个人认为，这个类之所以没有在我们开发中经常出现，确实是有道理的，后面的粒子发射器，实际上苹果在ios5的时候已经引入了CAEmitterLayer来做这个功能，那么我们使用这个类的场景也就剩下静态的展示多个图层的时候使用了，此外要说的是，由于layer不能像UIView那样的响应触摸事件，带有交互的场景是不适合它的，好了，下面附上我在github上的demo地址，感兴趣的朋友可以下载下来观看下。 ​ 另外，开场的苹果官方demo是用来镇场的 #35 参考资料 官方资料","link":"/2017/05/06/CAReplicatorLayer%E6%8E%A2%E7%A9%B6/"},{"title":"CoreGraphicsAndAnimation(1)","text":"绘图成品展示 UIBezierPath说到绘图，那么有一个不得不讲的对象，那就是UIBezierPath。先来看几个UIBezierPath里面比较重要的API。我都已经做了注释，功能还是比较强大的。 123456789101112131415161718192021+ (instancetype)bezierPath;//创建贝塞尔曲线+ (instancetype)bezierPathWithRect:(CGRect)rect;//获取矩形的贝塞尔曲线+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;//获取矩形框内椭圆的贝塞尔曲线+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius; //圆角贝塞尔曲线+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii;//矩形框内，指定圆角、半径的贝塞尔曲线+ (instancetype)bezierPathWithArcCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise;//指定圆心、半径、起始角度、时钟方向的贝塞尔曲线+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath;//根据CGPath创建贝塞尔曲线- (instancetype)init NS_DESIGNATED_INITIALIZER;- (void)moveToPoint:(CGPoint)point;//移动到某个点- (void)addLineToPoint:(CGPoint)point;//从当前点，添加线段到目标点- (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2;//贝塞尔三次方程，从当前点，到目标点，受控制点1、控制点2控制- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint;//贝塞尔二次方程，从当前点到目标点，受控制点1控制- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise NS_AVAILABLE_IOS(4_0);//添加椭圆路径，参数包括圆心，半径、开始角度，结束角度，时钟方向- (void)closePath;//关闭路径，当前大多是子路径，收到该消息之后，都会将首位点连接起来。- (void)fill;//填充封闭路径，根据当前context设置的颜色等参数- (void)stroke;//划线，根据当前context设置的线宽啊，颜色啊等参数- (void)addClip;//切边，调用该方法之后，只有封闭路径内可以继续操作，封闭路径外无法操作。@end 梯度梯度的实现在ios里面有俩种方式，一种是通过CAGradientLayer去绘制，一种是通过CGGradientRef使用DrawRect:方法去绘制，我这里采用的是第二种方式。 实现方式，首先创建了一个CYShapeView的基类，该类可以设置一些属性值，如外边界色，里边界色，划线色，线宽等。方便子类继承它。通过设置的这些属性，可以获取到需要的梯度Ref指针。 下面是具体的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@interface CYShapedView : UIView@property (nonatomic, strong) UIColor *innerColor;@property (nonatomic, strong) UIColor *outerColor;@property (nonatomic, strong) UIColor *strokeColor;@property (nonatomic, assign) CGFloat lineThickness;- (CGGradientRef)gradientWithColor:(UIColor *)c1 toColor:(UIColor *)c2 count:(CGFloat)colorNumb;@end @implementation CYShapedView- (id)initWithFrame:(CGRect)frame{ self = [super initWithFrame:frame]; if (self) { self.innerColor = [UIColor redColor]; self.outerColor = [UIColor yellowColor]; self.strokeColor = [UIColor blackColor]; self.lineThickness = 3.f; self.backgroundColor = [UIColor clearColor]; } return self;}- (void)setLineThickness:(CGFloat)lineThickness{ CGFloat totalWidth = self.bounds.size.width; CGFloat totalHeight = self.bounds.size.height; CGFloat halfWidth = totalWidth / 2.f; CGFloat halfHeight = totalHeight / 2.f; CGFloat smallest = MIN(halfWidth, halfHeight); CGFloat factor = smallest / 100.f; factor = (factor &gt; 1) ? 1 : factor; _lineThickness = factor * lineThickness;}- (CGGradientRef)gradientWithColor:(UIColor *)c1 toColor:(UIColor *)c2 count:(CGFloat)colorNumb{ // 获取颜色组成 const CGFloat *colorComponents1 = CGColorGetComponents(c1.CGColor); CGFloat r1 = colorComponents1[0]; CGFloat g1 = colorComponents1[1]; CGFloat b1 = colorComponents1[2]; const CGFloat *colorComponents2 = CGColorGetComponents(c2.CGColor); CGFloat r2 = colorComponents2[0]; CGFloat g2 = colorComponents2[1]; CGFloat b2 = colorComponents2[2]; CGFloat gradientColorComponents[] = { r1,g1,b1,1, r2,g2,b2,1, r1,g1,b1,1, }; // 使用RGB色生成颜色空间 CGColorSpaceRef rgb = CGColorSpaceCreateDeviceRGB(); // 根据RGB色和梯度色数组，以及梯度色个数，创建梯度引用 CGGradientRef gradientRef = CGGradientCreateWithColorComponents(rgb, gradientColorComponents, NULL, colorNumb); CGColorSpaceRelease(rgb); return gradientRef;}@end 使用梯度及UIBezierPath绘制一个叶子实现思路，创建一个继承自CYShapedView的子类，并将它命名为CYPetal。我们主要做的工作是在该类的DrawRect:方法里面 绘制一个叶子，首先要绘制的点有起点和终点，中间需要用曲线连接起来。那么接下来的工作就是找到这些点。 1234561. 起点（startPoint）：CGPointMake(self.view.bounds.size.width / 2, 3)2. 终点（endPoint）：CGPointMake(self.view.bounds.size.width/ 2,self.view.bounds.size.height);3. 左叶子控制点（leftCtl）：CGPointMake(-self.view.bounds.size.width / 2,self.view.bounds.size.height/ 3)4. 右叶子控制点（rightCtl）：CGPointMake(self.view.bounds.size.width *1.5,self.view.bounds.size.height/ 3)5. 中间控制点（midPoint）：CGPointMake(self.view.bounds.size.width / 2,self.view.bounds.size.height * 0.8)6. 边界点（corner）：该点用来设置梯度的终点CGPointMake(self.view.bounds.size.width, 0) 下面来形象的展示下这些点的位置 1234567891011121314/*---------------------------------------------------------------------------*/// -----------------------------------------// | . -&gt; start poin .|corner// . left ctl | | . right ctl// | |// | |// | |// | |// | mid point |// | . |// | |// | . -&gt; end pint |// -----------------------------------------/*----------------------------------------------------------------------------*/ 以下是具体的实现代码，其实找到点之后，再用代码实现就很容易了。 1234567891011121314151617181920212223242526- (void)drawRect:(CGRect)rect { CGFloat fullWidth = self.bounds.size.width; CGFloat fullHeight = self.bounds.size.height; CGFloat halfWidth = fullWidth / 2.f; CGFloat halfHeight = fullHeight / 2.f; CGPoint startPoint = CGPointMake(halfWidth, 3.f); CGPoint midPoint = CGPointMake(halfWidth, halfHeight * 1.6f); CGPoint endPoint = CGPointMake(halfWidth, fullHeight); CGPoint leftCtl = CGPointMake(-halfWidth, halfHeight / 3.f); CGPoint rightCtl = CGPointMake(fullWidth * 1.5f, halfHeight / 3.f); CGPoint corner = CGPointMake(fullWidth, 0); UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:startPoint]; [path addCurveToPoint:endPoint controlPoint1:leftCtl controlPoint2:midPoint]; [path addCurveToPoint:startPoint controlPoint1:midPoint controlPoint2:rightCtl]; [path addClip]; CGGradientRef gradient = [self gradientWithColor:self.innerColor toColor:self.outerColor count:3]; CGContextRef context = UIGraphicsGetCurrentContext(); CGContextDrawLinearGradient(context, gradient, CGPointZero, corner, 0); path.lineWidth = self.lineThickness; [self.strokeColor setStroke]; [path stroke];} 贴个图感受下最后绘制出来的叶子 绘制笑脸实现思路，同绘制叶子一样，我们先搞清楚需要的绘制参数。首先我们要绘制一个圆，用来显示脸。其次需要绘制一条曲线，用来显示嘴巴。最后还要绘制俩个椭圆用来显示眼睛。那么总结起来就是。 绘制圆，并做圆心向外发散的梯度处理 绘制曲线，俩个嘴角受中心点控制的贝塞尔曲线。 绘制椭圆，找到合适的位置调用贝塞尔的矩形框绘制椭圆路径即可。 实现的代码也比较简单，如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051- (void)drawRect:(CGRect)rect { // 基础点 CGFloat fullWidth = self.bounds.size.width; CGFloat fullHeight = self.bounds.size.height; CGFloat halfWidth = fullWidth / 2.f; CGFloat halfHeight = fullHeight / 2.f; CGFloat radius = MIN(halfWidth, halfHeight); CGPoint center = CGPointMake(halfWidth, halfHeight); // bezierPath 切圆 UIBezierPath *bezier = [UIBezierPath bezierPath]; [bezier addArcWithCenter:center radius:radius startAngle:0 endAngle:M_PI * 2 clockwise:YES]; [bezier addClip]; // 填充梯度，从中心发散 CGGradientRef gradient = [self gradientWithColor:self.innerColor toColor:self.outerColor count:2]; CGContextRef graphics = UIGraphicsGetCurrentContext(); CGContextDrawRadialGradient(graphics, gradient, center, 0, center, radius, 0); // 划线 bezier.lineWidth = self.lineThickness * 1.7; [self.strokeColor setStroke]; [bezier stroke]; // 准备画嘴巴 [bezier removeAllPoints]; bezier.lineWidth = self.lineThickness; [bezier moveToPoint:CGPointMake(halfWidth * 0.5, halfHeight * 1.3)]; [bezier addQuadCurveToPoint:CGPointMake(halfWidth * 1.5, halfHeight * 1.3) controlPoint:CGPointMake(halfWidth, fullHeight * 0.91)]; [bezier stroke]; // 准备画左眼 bezier = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(fullWidth / 3 - halfWidth * .1, fullHeight / 3.f, halfWidth * .2, halfHeight * .3)]; bezier.lineWidth = self.lineThickness; [bezier fill]; [bezier stroke]; // 画右眼 bezier = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(fullWidth / 3 * 2 - halfWidth * .1, fullHeight / 3.f, halfWidth * .2, halfHeight * .3)]; bezier.lineWidth = self.lineThickness; [bezier fill]; [bezier stroke];} 按照惯例，贴下实现的效果图 动起来现在我们希望能用之前绘制的俩个图形，集合动画，做出一个类似太阳的动画特效。 还是谈谈实现的思路：先用之前的CYSmile绘制一个太阳，之后采用CYPetal绘制一组阳光，阳光的绘制有技巧，需要绘制相同frame的光芒视图15个，之后采用transform的方式，设置位置偏移。此外由于要实现动画效果，需要对光芒的锚点位置进行设置。以下是一个view设置的时候，太阳和光芒的位置设置。 12345678910111213141516171819202122----------------------------------------------------------------------| || || || ------------------------------- || | ------- | || | | | | || | | 光 | | || | | 芒 | | || | | 区 | | || | | | | || | | | | || | ------- | || | | || | 太阳区 | || | | || ------------------------------- || || || || |------------------------------------------------------------------------ 具体的话还是看下代码吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071- (void)createSunshine{ // 设置大小 CGFloat fullWidth = self.bounds.size.width; CGFloat fullHeight = self.bounds.size.height; CGFloat halfWidth = fullWidth / 2.f; CGFloat halfHeigt = fullHeight / 2.f; // 设置太阳和光芒的位置 CGRect sunRect = CGRectMake(halfWidth - fullWidth / 4, halfHeigt - fullHeight / 4, halfWidth, halfHeigt); CGRect sunshineRect = CGRectMake(halfWidth - fullWidth / 40, halfHeigt - fullHeight / 8, fullWidth / 20, fullHeight / 4); // 创建光芒所在的view，并将本类的shineLayer指向它的layer，方便后面添加动画 UIView *shineView = [[UIView alloc]initWithFrame:self.bounds]; self.shineLayer = shineView.layer; [self addSubview:shineView]; // 将光芒都添加到光芒view上，并进行相应的transform转换和锚点设置 for (CGFloat i = M_PI / 10; i &lt; M_PI * 2; i += M_PI / 7.5) { CYPetal *petal = [[CYPetal alloc]initWithFrame:sunshineRect]; petal.innerColor = [UIColor yellowColor]; petal.outerColor = [UIColor colorWithRed:1 green:0.8 blue:.2 alpha:1]; petal.lineThickness = 40.f; petal.strokeColor = [UIColor whiteColor]; [shineView addSubview:petal]; petal.layer.anchorPoint = CGPointMake(.5, 2); petal.transform = CGAffineTransformMakeRotation(i); } // 添加动画，让光芒动起来 [self addRotationAnimation]; // 添加太阳 CYSmile *smile = [[CYSmile alloc]initWithFrame:sunRect]; smile.innerColor = [UIColor yellowColor]; smile.outerColor = [UIColor colorWithRed:1 green:.8 blue:.2 alpha:1]; [self addSubview:smile]; }- (void)addRotationAnimation{ CABasicAnimation *basicAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation&quot;]; // 设置旋转动画 basicAnimation.duration = 10; basicAnimation.fromValue = @0; basicAnimation.speed = self.speed; basicAnimation.toValue = @(M_PI * 2); basicAnimation.repeatCount = CGFLOAT_MAX; [self.shineLayer addAnimation:basicAnimation forKey:@&quot;rotation&quot;]; // 设置透明度动画 basicAnimation.keyPath = @&quot;opacity&quot;; basicAnimation.duration = .5f; basicAnimation.autoreverses = YES; basicAnimation.fromValue = @0.7; basicAnimation.toValue = @1.0; [self.shineLayer addAnimation:basicAnimation forKey:@&quot;fade&quot;]; // 设置大小动画 basicAnimation.keyPath = @&quot;transform.scale&quot;; basicAnimation.fromValue = @0.9; basicAnimation.toValue = @1.1; [self.shineLayer addAnimation:basicAnimation forKey:@&quot;scale&quot;]; } 最后的效果图如下 组合绘制花朵花朵包括的元素主要有笑脸、花瓣、茎、叶子。这些元素（除了茎）都可以使用之前的组件来绘制出来。 茎坐标路径大概如下,并不一定是这样，手工绘制敬请谅解 12345678910111213141516171819202122/* ------------------------------------------------------------------------ | . start point corner .| | . . | | . . | | . . | | . . | | . . | | . . | | . . | |. left ctrl . ..mid point | | . . | | . . | | . . | | . . | | . . | | . . | | . . | | . . | | . end point right ctrl . | ------------------------------------------------------------------------ */ 茎的绘制和之前花瓣的绘制差不多，都是要选择一个起点和一个终点，然后绘制根据俩个锚点，绘制出相应的图形，具体绘制就不细说了，还是附上代码感受下吧 12345678910111213141516171819202122232425262728293031- (void)drawRect:(CGRect)rect{ CGFloat fullWidth = self.bounds.size.width; CGFloat fullHeight = self.bounds.size.height; CGFloat halfWidth = fullWidth / 2; CGFloat halfHeight = fullHeight / 2; CGPoint startPoint = CGPointMake(halfWidth * .9, 0); CGPoint midPoint = CGPointMake(halfWidth, halfHeight); CGPoint endPoint = CGPointMake(halfWidth * .9, fullHeight); CGPoint corner = CGPointMake(fullWidth, 0); CGPoint leftCtl = CGPointMake(0, halfHeight); CGPoint rightCtl = CGPointMake(fullWidth, fullHeight); UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:startPoint]; [path addCurveToPoint:endPoint controlPoint1:leftCtl controlPoint2:rightCtl]; [path addCurveToPoint:startPoint controlPoint1:rightCtl controlPoint2:midPoint]; [path closePath]; [path addClip]; CGContextRef ref = UIGraphicsGetCurrentContext(); CGGradientRef gradient = [self gradientWithColor:self.innerColor toColor:self.outerColor count:3]; CGContextDrawLinearGradient(ref, gradient, CGPointZero, corner, 0); path.lineWidth = self.lineThickness; [self.strokeColor setStroke]; [path stroke]; } 组合花朵组合花朵，主要就是在于计算笑脸、茎、花瓣、叶子等的坐标位置。然后还有就是设置它们的颜色。此外要注意设置花朵的frame的时候，要保持宽高比为7 : 10，这样才能生成比较好的效果。 下面附上花朵的位置设置代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859- (id)initWithFrame:(CGRect)frame{ self = [super initWithFrame:frame]; if (self) { [self p_createFlower]; } return self;}- (void)p_createFlower{ // 贴图的时候注意要由下而上，由内而外的贴。 CGFloat fullwidth = self.bounds.size.width; CGFloat fullHeight = self.bounds.size.height; CGFloat halfWidth = self.bounds.size.width/2.f; CGFloat halfHeight = self.bounds.size.height/2.f; // 位置的计算是最麻烦 CGRect smileRect = CGRectMake(halfWidth/2, halfHeight/4*.9, halfWidth, halfHeight); CGRect petalRect = CGRectMake(halfWidth-fullwidth/10, fullHeight/5, fullwidth/5, fullwidth/2); CGRect leafRect = CGRectMake(halfWidth-fullwidth/12, fullHeight*.84, fullwidth/5, fullwidth/2); CGRect stemRect = CGRectMake(halfWidth-fullwidth/8, halfHeight*1.3, fullwidth/4, halfHeight*.8); // 贴茎 CYStem *stem = [[CYStem alloc]initWithFrame:stemRect]; stem.outerColor = [UIColor colorWithRed:0 green:0.5 blue:0 alpha:1]; stem.innerColor = [UIColor colorWithRed:.3 green:1 blue:.2 alpha:1]; [self addSubview:stem]; // 贴花瓣 for (CGFloat i = M_PI / 10; i &lt; M_PI * 2; i += M_PI / 7.5) { CYPetal *petal = [[CYPetal alloc]initWithFrame:petalRect]; petal.outerColor = [UIColor purpleColor]; petal.innerColor = [UIColor colorWithRed:1 green:0 blue:1 alpha:1]; [self addSubview:petal]; petal.layer.anchorPoint = CGPointMake(.5, 1); petal.transform = CGAffineTransformMakeRotation(i); } // 贴叶子 for (CGFloat i = -M_PI/5; i &lt;= M_PI/5; i += M_PI * 2/5) { CYPetal *leaf = [[CYPetal alloc]initWithFrame:leafRect]; leaf.outerColor = [UIColor colorWithRed:0 green:.5 blue:0 alpha:1 ]; leaf.innerColor = [UIColor colorWithRed:.3 green:1 blue:.2 alpha:1]; [self addSubview:leaf]; leaf.layer.anchorPoint = CGPointMake(.5, 1); leaf.transform = CGAffineTransformMakeRotation(i); } // 贴笑脸 CYSmile *smile = [[CYSmile alloc]initWithFrame:smileRect]; smile.innerColor = [UIColor yellowColor]; smile.outerColor = [UIColor colorWithRed:1 green:.4 blue:0 alpha:1]; [self addSubview:smile]; } 参考资料","link":"/2017/05/12/CoreGraphicsAndAnimation/"},{"title":"CoreGraphicsAndAnimations(2)","text":"绘图（2）图层合并及Flower生长动画图层合并图层的合并说起来很高大上，其实实际上在IOS里面实现非常的简单，实现原理就是，先获取当前的图片绘图上下文，将当前view的layer渲染到当前的绘图上下文，之后从当前的上下文中获取图片，最后结束当前上下文。返回获取到的图片 可能看代码更直观些。 注：这是一个view的category方法 12345678910- (UIImage *)cy_compositedView{ UIGraphicsBeginImageContext(self.bounds.size); [self.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage *compositedImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return compositedImage; } Flower 生长动画flower的生长主要注意的地方就俩点，一个是花的位置安排，一个是花的生长动画。位置的话，需要注意的是我们希望看起来大的花和位置靠下的花，尽量能往前放。这样会有一些层次感。生长动画的话就是希望锚点能在根部，这样会有一种长起来的感觉。 还有需要注意的就是，我们这里只使用了一个Flower类，然后用这个类去生成了🌺的图片。然后采用初始化UIImageView贴图片的方式创建60朵🌺，这样能大大的节省内存空间。 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (void)addFlowers{ CGFloat height = self.view.bounds.size.height; CGFloat width = self.view.bounds.size.width; // 花的高度 CGFloat flowerHeight = height / 6; // 花的起始位置 CGFloat flowerY = height * 0.3; // 创建花 CYFlower *flower = [[CYFlower alloc]initWithFrame:CGRectMake(0, 0, flowerHeight * .7, flowerHeight)]; // 生成花图片 UIImage *floweimg = [flower cy_compositedView]; // 贴花 for (int i = 0; i &lt; 60; i ++) { int size = height / 12.f; CGFloat flowersize =( arc4random() % (int) size) + size; UIImageView *flowerImgView = [[UIImageView alloc]initWithFrame:CGRectMake(arc4random()%(int)width * 0.9, arc4random() % (int)flowerY + 2 * flowerY, flowersize * .7, flowersize)]; flowerImgView.image = floweimg; // z position设置，这样会有层次感 flowerImgView.layer.zPosition = flowerImgView.frame.origin.y + flowersize; [self.view addSubview:flowerImgView]; // 花生长 [self growFlowers:flowerImgView duration:arc4random() % 100 / 25 + 4]; } }- (void)growFlowers:(UIImageView *)flowers duration:(CGFloat)duration{ // 花锚点设置 flowers.layer.anchorPoint = CGPointMake(.5, 1); // 添加动画 CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;]; animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; animation.duration = duration; animation.fromValue = [NSValue valueWithCGSize:CGSizeMake(0, 0)]; animation.toValue = [NSValue valueWithCGSize:CGSizeMake(1, 1)]; [flowers.layer addAnimation:animation forKey:@&quot;grow&quot;];} 下面附上生长动画 利用梯度layer实现太阳升起的动画ios里面有一个layer叫CAGradientLayer，这个layer支持线性的梯度，最为关键的是，它有一个colors属性支持动画效果。我们只需要给这个colors数组里面填充颜色对象就可以了，另外我们还希望能够从起点到结束点有个过度。那么需要对startPoint属性做动画。 最后，不希望视图生成的时候就开始动画，而是在视图贴到父视图上的时候才开始动画，那么layer的动画就要加在-(void)didMoveToSuperView方法上。以下是具体实现代码 1234567891011121314151617181920212223242526272829303132333435363738394041+ (Class)layerClass{ return [CAGradientLayer class];}- (void)didMoveToSuperview{ self.backgroundColor = [UIColor blackColor]; CGColorRef blackcolor = [[UIColor blackColor]CGColor]; UIColor *color1 = [UIColor colorWithRed:0.01 green:0.2 blue:0.8 alpha:1]; UIColor *color2 = [UIColor colorWithRed:1 green:0.5 blue:0 alpha:1]; UIColor *color3 = [UIColor colorWithRed:.35 green:.74 blue:.11 alpha:1]; NSArray *colors = [NSArray arrayWithObjects:(id)[color1 CGColor], [color2 CGColor], [color3 CGColor], nil]; NSNumber *location1 = [NSNumber numberWithFloat:.0]; NSNumber *location2 = [NSNumber numberWithFloat:.4]; NSNumber *location3 = [NSNumber numberWithFloat:.9]; CAGradientLayer *layer = (CAGradientLayer *)[self layer]; layer.colors = colors; layer.locations = @[location1,location2,location3]; layer.startPoint = CGPointMake(.5, 0); layer.endPoint = CGPointMake(.5, 1); CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@&quot;startPoint&quot;]; animation.duration = 6.f; animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut]; animation.fromValue = [NSValue valueWithCGPoint:CGPointMake(.5, 1)]; [layer addAnimation:animation forKey:@&quot;start&quot;]; animation.keyPath = @&quot;colors&quot;; animation.duration = 6.f; animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut]; animation.fromValue = [NSArray arrayWithObjects:(__bridge id)blackcolor, blackcolor, blackcolor, nil]; [layer addAnimation:animation forKey:@&quot;color&quot;];}@end 老规矩附上一张实现的效果图 云彩飘动接下来，我们希望实现的是开篇的时候，展示的云朵从屏幕左侧飘移到屏幕右侧的动画，这里有几个需要注意的点 云朵轨迹 云朵投影 云朵投影和云朵要一起动。 实现方式的话，这里采用UIBezierPath绘制轨迹，然后内部采用梯度进行填充。云朵的投影采用云朵一半的高度绘制，然后将其设置为云朵的ShadowPath，然后利用shadowoffset属性将云朵投射到足够远的距离，形成一种投影的效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162- (void)drawRect:(CGRect)rect{ CGFloat height = self.bounds.size.height; UIBezierPath *path = [self createCloudPathWithHeight:height]; [path addClip]; CGGradientRef gradientRef = [self gradientWithColor:self.innerColor toColor:self.outerColor count:2]; CGContextRef context = UIGraphicsGetCurrentContext(); CGPoint startPoint = CGPointMake(0, 0); CGPoint endPoint = CGPointMake(0, height); CGContextDrawLinearGradient(context, gradientRef, startPoint, endPoint, 0); path.lineWidth = self.lineThickness; [self.strokeColor setStroke]; [path stroke]; UIBezierPath *shadowPath = [self createCloudPathWithHeight:height / 2]; self.layer.shadowPath = shadowPath.CGPath; if (!self.distance) { self.distance = height * 1.8; } self.layer.shadowOffset = CGSizeMake(0, self.distance); self.layer.shadowOpacity = 0.4f; self.alpha = 0.9f; }- (UIBezierPath *)createCloudPathWithHeight:(CGFloat)height{ CGFloat width = self.bounds.size.width; CGFloat points[] = { 0.4,0.2, 0.5,0.1,0.6,0.2, 0.8,0.2,0.8,0.4, 0.9,0.5,0.8,0.6, 0.8,0.8,0.6,0.8, 0.5,0.9,0.4,0.8, 0.2,0.8,0.2,0.6, 0.1,0.5,0.2,0.4, 0.2,0.2,0.4,0.2, }; CGPoint cPoint; CGPoint point; UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:CGPointMake(points[0] * width, points[1] * height)]; for (int i = 2; i &lt; sizeof(points) / sizeof(CGFloat); i += 4) { cPoint = CGPointMake(points[i] * width, points[i + 1] * height); point = CGPointMake(points[i + 2] * width, points[i + 3] * height); [path addQuadCurveToPoint:point controlPoint:cPoint]; } [path closePath]; return path;} 实现的效果图如下 海鸥进行到现在，跟成品图中相差的也就剩下最后一步了，那就是海鸥的绘制，海鸥这里同样还是采用Bezier曲线绘制，不同的是，我们要采用onscreen渲染的方式，绘制出多张海鸥的image，最后将image组合成一个数组，然后用UIImageView的images数组进行展示。 以下是具体绘制代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)didMoveToSuperview{ if (!self.animationImages) { self.animationImages = [self arrayofImages]; }}- (NSArray *)arrayofImages{ NSMutableArray *arr = [NSMutableArray arrayWithCapacity:COUNT]; for (CGFloat i = LOWWING; i &lt; HEIGING; i+=STEP) { [arr addObject:[self animationFrame:i]]; } for (CGFloat i = HEIGING; i &gt; LOWWING; i -= STEP) { [arr addObject:[self animationFrame:i]]; } return arr;}- (UIImage *)animationFrame:(CGFloat)frame{ CGFloat width = self.bounds.size.width; CGFloat height = self.bounds.size.height; UIGraphicsBeginImageContextWithOptions(CGSizeMake(width, height), NO, 0); UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:CGPointMake(0, frame)]; [path addQuadCurveToPoint:CGPointMake(.5, 0.6 - frame / 3) controlPoint:CGPointMake(.25, .25)]; [path addQuadCurveToPoint:CGPointMake(1, frame) controlPoint:CGPointMake(.75, .25)]; [path applyTransform:CGAffineTransformMakeScale(width, height)]; path.lineWidth = height / 30; [path stroke]; UIImage *imge = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return imge;} 效果图 小结通过学习绘制图形以及给layer做动画，基本掌握了一些常用的绘制函数和动画实现方法。发现CoreGraphics确实是一个强大的图形绘制库，只要你脑洞大开就能绘制你想到的任意图形，此外图层合并能够大大节省内存空间，如果是静态的多个图层的view。可以考虑做图层渲染，渲染成图片。 附录最后附上本项目在git上的demo，感兴趣的朋友可以下载下来看看，欢迎star。","link":"/2017/05/19/CoreGraphicsAndAnimations-2/"},{"title":"","text":"背景介绍 Django是一个开放源代码的Web应用框架，由Python写成。采用了MTV的框架模式，即模型M，视图V和模版T。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的。2019年12月2日，Django 3. 0发布 。目前的django版本是4.2.3 官网地址MTV 模型Django 的 MTV 模式本质上和 MVC 是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同，Django 的 MTV 分别是指：● M 表示模型（Model）：编写程序应有的功能，负责业务对象与数据库的映射(ORM)。● T 表示模板 (Template)：负责如何把页面(html)展示给用户。● V 表示视图（View）：负责业务逻辑，并在适当时候调用 Model和 Template。除了以上三层之外，还需要一个 URL 分发器，它的作用是将一个个 URL 的页面请求分发给不同的 View 处理，View 再调用相应的 Model 和 Template，MTV 的响应模式如下所示：简易图： 用户操作流程图： 解析：用户通过浏览器向我们的服务器发起一个请求(request)，这个请求会去访问视图函数： ● a.如果不涉及到数据调用，那么这个时候视图函数直接返回一个模板也就是一个网页给用户。● b.如果涉及到数据调用，那么视图函数调用模型，模型去数据库查找数据，然后逐级返回。视图函数把返回的数据填充到模板中空格，最后返回网页给用户。Django 的设计思想 • DRY（Don’t repeat yourself）：不重复造轮子• MVT• 快速开发• 灵活易于扩展• 松耦合• 显式优于隐式 django适合做什么 ● 内容管理系统• 博客• CMS• Wiki● 企业内部系统• 会议室预定• 招聘管理• ERP &amp; CRM• 报表系统● 运维管理系统• CMDB• 发布管理• 作业管理• 脚本管理• 变更管理• 故障管理有哪些产品在使用django 本课程的大纲 Django 开发环境准备 Python 开发环境准备 – PyCharm 介绍• PyCharm IDE，出自 JetBrains 公司，IDEA 系列产品为 JetBrains 产出的产品• 最好用的免费 Python IDE• PyCharm 有 Community 版本，有 Enterprise 版本• PyCharm 社区版不支持 Django 开发， 但可以安装 Django 类库，能够实现 Django 代码的自动提示安装 PyCharm 下载地址新建一个django项目 选择一个目录，并在命令行输入以下内容 django startproject recruitmentcd recruitmentpython3 manage.py startapp jobpython3 manage.py runserver 0.0.0.0:8000 修改allow hostALLOWED_HOSTS = [‘0.0.0.0’] 创建一个超级管理管，并按照提示输入用户名、密码python3 createsuperuser django项目的目录结构 登录django后台 Django 的自定义模板 • Django 模板包含了输出的 HTML 页面的静态部分的内容• 模板里面的动态内容在运行时被替换• 在 views 里面指定每个 URL 使用哪个模板来渲染页面• 模版继承与块（Template Inheritance &amp; Block） • 模板继承允许定义一个骨架模板，骨架包含站点上的公共元素（如头部导航，尾部链接）• 骨架模板里面可以定义 Block 块，每一个 Block 块都可以在继承的页面上重新定义/覆盖• 一个页面可以继承自另一个页面• 定义一个匿名访问页面的基础页面，基础页面中定义页头• 添加页面 job/templates/base.html 添加 URL 路径映射 • 让添加的页面，能够通过 URL 访问到• /joblist/ 的路径访问到 views 里面定义的 joblist 视图• 这个视图时一个 Method View，方法表示一个视图 列表展示 ● 模板添加定义，View 页面添加完，URL 中也定义路由之后，再访问页面：● http://127.0.0.1:8000/joblist/ 配置日志记录 ● Django 里面使用 dictConfig 格式来配置日志● Dictionary 对象，至少包含如下内容: ○ version, 目前唯一有效的值是 1 ○ Handler, logger 是可选内容，通常需要自己定义 ○ Filter, formatter 是可选内容，可以不用定义● 定义日志输出格式， 分别定义 全局日志记错， 错误日志处理， 自定义的 日志处理器 发送通知：钉钉群消息集成 • 安装钉钉聊天机器人： pip install DingtalkChatbot• 测试群消息• python ./manage.py shell –settings=settings.local• from interview import dingtalk• dingtalk.send(“秋季招聘面试启动通知, 自 2020/09/01 开始秋季招聘”)• 定义 通知面试官的方法def notify_interviewer(modeladmin, request, queryset)• 注册到 modeladmin中actions = (export_model_as_csv, notify_interviewer, ) django的中间件 ● 什么是中间件 Middleware ?● 注入在 Django 请求/响应 处理流程中的钩子框架，能对 request/response 作处理● 广泛的使用场景 ○ 登录认证，安全拦截 ○ 日志记录，性能上报 ○ 缓存处理，监控告警….● 自定义中间件的 2 种方法● 使用函数实现● 使用类实现示例创建一个请求日志，性能日志记录中间件 输出到 Response Header 里面的 X-Page-Ducration-ms Sentry 集成 解决的问题： 应用的错误，异常监控统计，报警通知；性能监控统计，对问题进行跟踪Sentry 架构之美• 开放的架构：可与 AD 域账号集成，与 Google/Stackoverflow 等账号集成• 有完善的插件支持：Webhook/Gitlab/Jira/Slack/PushOver/….• 支持不同环境（开发、测试、预发、线上）；可以配置灵活的告警• 跨平台，跨端的支持：Python/Java/JavaScript/Ruby/Go/…, Android/iOS/Web/…• API 简单、易用，自动集成；安装简单：架构依赖多，但使用 Docker 可以一个命令安装• 自动对错误，异常进行统计聚合，按照上下文的Tag进行聚合• 可以对性能进行统计分析，可抽样;可视化的趋势分析• 多租户，支持双因素认证，敏感内容自动脱敏 两种方法安装 Sentry ： 使用 Docker 官方服务（量大需要付费，使用方便）； 自己搭建 服务（从源码安装，或者使用docker 搭建服务）； 使用 Docker 来安装 sentry, 使用 release 版本 https://github.com/getsentry/onpremise/releases ./install.sh docker-compose up -d Django 配置集成 sentry ， 自动上报未捕获异常， 错误日志 集成效果 告警趋势可视化: Prometheus &amp; Grafana Prometheus 数据类型• Counter：计数器，总是增长的整数值；请求数，订单量，错误数等；• Gauge：可以上下波动的计量值，比如温度，内存使用量，处理中的请求；• Summary：提供观测样本的摘要，包含样本数量，样本值的和；滑动窗口计算:请求耗时，响应数据大小• Histogram：把观测值放到配置好的桶中做统计，请求耗时，响应数据大小等； Django 中使用缓存 ● Django 缓存的存储方式 Memcached 缓存 Redis 缓存 （需要安装 django-redis 包） 数据库缓存 文件系统缓存 本地内存缓存 伪缓存( Dummy Cache， 用于开发、测试) • 自定义缓存 Celery 集成：Celery 的使用 ● 什么是 Celery?● 一个分布式的任务队列 ○ 简单： 几行代码可以创建一个简单的 Celery 任务 ○ 高可用：工作机会自动重试 ○ 快速：可以执行一分钟上百万的任务 ○ 灵活：每一块都可以扩展 Celery 中的核心概念 • Task: 一个需要执行的任务，任务通常异步执行• Period Task: 需要定时执行的任务，定时一定间隔执行，也可以使用 crontab 表达式设定执行周期和时间点• Message Broker: 消息代理，临时存储，传输任务到工作节点的消息队列。可以用 Redis,RabbitMQ, Amazon SQS 作为消息代理。消息代理可以有多个，以保障系统的高可用。• Worker：工作节点，执行任务的进程，worker可以有多个，保障系统的高可用和扩展性。 Celery 使用场景 大量需要使用异步任务的场景• 发送电子邮件，发送 IM 消息通知• 爬取网页， 数据分析• 图像、视频处理• 生成报告，深度学习 Flower: 一个实时的 Celery 任务监控系统 Django之美：Signals信号及其使用场景 什么是 Signals?• Django 的信号• Django 框架内置的信号发送器，这个信号发送器在框架里面• 有动作发生的时候，帮助解耦的应用接收到消息通知• 当动作发生时，允许特定的信号发送者发送消息到一系列的消息接收者• Signals 是同步调用 信号的应用场景• 系统解耦；代码复用：实现统一处理逻辑的框架中间件； -&gt; 可维护性提升• 记录操作日志，增加/清除缓存，数据变化接入审批流程；评论通知；• 关联业务变化通知，• 例：通讯录变化的异步事件处理，比如员工入职时发送消息通知团队新人入职，员工离职时异步清理员工的权限等等； 生产环境中的安全：应用安全 访问限流 – 防恶意攻击• Rest Framework API 限流• 应用限流: 对页面的访问频次进行限流 可以对匿名用户，具名用户进行限流可以设置峰值流量（如每分钟60次请求）也可以设置连续一段时间的流量限制（比如每天3000次） 云环境中的部署：容器的基础用法 – Docker 容器介绍 ● Docker: ○ 码头工人，轻量级的，可移植，自包含的容器，来自动化、版本化应用的发布。 ○ Docker上跑的容器是一个个的集装箱；● Docker的基础是LXC ○ LXC用于应用程序的隔离，每个应用程序分配独立的命名空间，隔离的CPU, 内存，磁盘，网络资源 ○ 每个应用内部可以单跑一套容器系统，功 能上相当于传统的虚拟机，但本质上是内核层面对资源的隔离● Docker 容器的分层和版本管理 ○ Docker把应用和系统打包到一起（image镜像），进行版本化管理。 ○ 应用之于Docker，如同代码之于Git/SVN，一个命令可以把应用部署到docker上。容器的基础用法 持续集成：CICD的工作流程","link":"/2023/08/28/Django%E5%BC%80%E5%8F%91%E5%88%86%E4%BA%AB/"},{"title":"Fastlane多设备管理证书","text":"","link":"/2023/08/28/Fastlane%E5%A4%9A%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E8%AF%81%E4%B9%A6/"},{"title":"Hexo使用手册","text":"Hexo手册 1.启动本地调试服务器1hexo server 2.新建文章1hexo new '文章标题' 3. 静态文件生成1hexo generate 4. 文章发布1hexo deploy 5.图片放置将用的图片放置到 “文章标题”/ 文件夹下面 使用的时候 1![](文章标题/图片.jpg)","link":"/2019/09/19/Hexo%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"},{"title":"Python学习笔记（一）","text":"今天开一个专题，来记录下学习python的一些笔记 1、 打印输出123#encoding:utf-8print('hello world')print('你好，世界') 2、变量声明123456789101112#声明一个字符串monday='星期一'#声明一个int类型的数字one=1#声明一个浮点类型的数字pi=3.14#声明一个数组arr=['1','2',2222]#声明一个字段dic={'name':'成焱','age':22}#声明一个bool类型的boolvalue=False 3、常用字符串操作函数 求字符串长度 1stringlength=len(monday) 字符串拼接 123string1='你好'string2='成焱'string3=string1+string2 格式化字符串输出 1234567891011121314151617Python转换说明符转换说明符 说明%d，%i 转换为带符号的十进制形式的整数%o 转换为带符号的八进制形式的整数%x，%X 转换为带符号的十六进制形式的整数%e 转化为科学计数法表示的浮点数（e 小写）%E 转化为科学计数法表示的浮点数（E 大写）%f，%F 转化为十进制形式的浮点数%g 智能选择使用 %f 或 %e 格式%G 智能选择使用 %F 或 %E 格式%c 格式化字符及其 ASCII 码%r 使用 repr() 将变量或表达式转换为字符串%s 使用 str() 将变量或表达式转换为字符串如print(monday+'%d'%one)输出：星期一1 4、数据类型转换 int(x) ： x为数字或字符串型的数字 float(x)：x为数字为字符串型的数字 complex(x，y)：转换为复数，x，y为数字，浮点数，bool数 str(x)：转为字符串 bin(x)：转为二进制数 oct(x)：转为8进制数 hex(x)：转为16进制数 chr(x)：将10进制数转为ASCII码 ord(x)：将ASCII字符转为10进制数 5、条件控制语句12345678910111213141516171819isBoy=True#单层判断if isBoy: print('男孩')#双重判断if isBoy: print('男孩')else: print('女孩') #多重判断if 1: print(2)elif 2: print(32)else: print(3) 6、循环控制语句 for循环 1234567891011121314for i in range(10): print(i)#输出0123456789 带步长循环打印 12345678for i in range(0,10, 2): print(i)#输出02468 循环一个数组 123456for var in arr: print(var)#输出122222 while 循环 123456789i = 0while i &lt; 3: print(i) i+=1#输出 012 7、成员运算符 in，not in12345678910if 2 in range(10): print('2在集合中')else: print('2不在集合中') animals=['猫','狗','猪']if '桌子' not in animals: print('桌子不属于动物')else: print('桌子属于动物') 8、身份运算符 is ，is not1234567891011121314151617181920i = 1j = 1if i is j: print('i 就是 j')else: print('i 不是 j')#输出：i 就是 jname1='成焱'nickname='chengyan'if name1 is not nickname: print('成焱不是chengyan')else: print('成焱就是chengyan') #输出成焱不是chengyan 小结：本篇就先学习到这里，回顾下，本篇主要学习了python如何打印输出、字符串的常见操作、变量的声明、条件控制语句、数据类型转换、格式化输出字符串、身份变量符和成员变量符，下一节学习列表与元组、字典，see u tomorrow！","link":"/2019/10/16/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"Hexo升级3.9.0实践","text":"一、诉求hexo使用了好几年了，使用的版本一直是3.2.0, node 版本也是4.5.9版本，当前很多的node_models要去的版本都是6.0以上了，所以今天对hexo和node进行一次升级，全部都升级到最新版本。 hexo-&gt;3.9.0 node-&gt;10.16.3 具体带来的好处是页面打开速度加快、使用最新的插件，升级完成之后，可以支持文章字数统计和阅读时间统计。此外，还有一点就是以前一直对写的文章的代码区，不是很满意。此次也一并解决。 二、升级方案 node升级方案 hexo升级方案 hexo文字字数与hexo阅读时间改造 这里要多说几句，由于有两个方案实现这个功能，一种是通过npm install hexo-wordcount --save这种方式，误导文章，浪费了很多时间在这里。而正是的方式应该是 $ npm install hexo-symbols-count-time --save 最终总算是找到正确的姿势，文章也实现了字数与阅读时间的统计 三、意外产物在升级过程中，意外搞出来一些其他小的东西，如代码支持暗黑模式（这个功能以前也有，没有找到地方进行设置）、尾部贴了一个微信的二维码（希望能跟网友更多的交流）、另外还意外发现一个赞赏的功能，也打开了（如果有网友愿意的话！）。 四、还没实现，可以继续优化的点目前我使用的Hexo，Next主题总得来说，已经比较满意了，但是美中不足的是，多说下线之后，没有找到合适的替代方案，所以评论这块还是一个待优化的点。 五、其他一些有用的链接 Hexo主题网站","link":"/2019/10/17/Hexo%E5%8D%87%E7%BA%A73-9-0%E5%AE%9E%E8%B7%B5/"},{"title":"Python学习笔记（三）","text":"今天来继续学习下pytho中的函数 学习目标 如何定义函数及带不同参数的函数 函数模块 global、nonlocal、lambda 如何定义函数 无入参的函数 12def sayHello(): print(hello) 带返回值的函数 1234def sayHello(): hello = 'hello' print(hello) return hello 带参数函数 12def saySomething(something): print(something) 有默认值函数 12def sayDefault(something='helloworld'): print(something) 可变参数* ,** 123456def sayMore(*morething): for a in morething: print(a)def sayMoreDic(**moreDic): for dic in moreDic: print(dic) *修饰的参数，其实是一个元组，**修饰的参数是一个字典，传入方式如下 12sayMore(1,2,3)sayMoreDic(name='chengyan',age=10) 传字典、列表和元组 传字典和列表进入函数，在函数内修改，也会同步修改外面的值 传数字、字符串、元组进入函数，在函数内修改，并不会同步修改外面的值 函数模块 定义 在python里面，新建不同的.py文件，就相当于是创建了函数模块。 引用 通过关键字import xx 来引用相同目录下的文件，这么引用到的函数如果想调用，需要这么写 123import xxxx.sayHello() from xx import xxx 其中“xx”是模块名称，也就是文件名，”xxx”是我们要引用的函数名称，这么写有一个好处，是可以在调用函数的时候，略去”.”例如 12from xx import sayHellosayHello() 还有一种写法是from xx import *,这种写法的话，会引入所有的函数 模块搜索路径 123import syssys.path[0] = '函数模块所在路径'#通过sys.path函数来指定模块搜索路径，用来解决代码文件不在一个文件夹下的问题 global、nonlocal、lambda关键字 global 关键字用来在局部作用域内，声明变量为全局变量，从而可以修改全局变量 nonlocal 关键字用来修改闭包中的变量，将闭包变量修改为局部变量，从而可以修改闭包变量 lambda 关键字是用来申明匿名函数的，范例如下 12sum1 = lambda x,y: x+yprint(sum1(2,7)) 今天主要是学习了下函数的声明、调用、引用以及几个关于函数的关键字，下一节学习基础部分的最后一节类","link":"/2019/10/30/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"},{"title":"Python学习笔记（二）","text":"今天来学习下Python中的数组、元组和字典 一、数组 数组的声明，python的数组可以存放任何类型的数据，数组的声明如下 12#数组的声明list = [1, 2, 'chengyan',['chengyan',1]] 数组元素的获取，支持根据下标进行获取 123#根据下标获取print(list[0])#将会打印1 列表常用的方法** 方法名称 方法功能描述\u0010\u0010 append 在列表尾部拼接元素 clear 列表清空（python3.3之后支持） copy 复制生成另一个列表（3.3后支持） count 统计指定元素个数 extend 合并两个列表 index 获取指定元素的下标 insert 在指定位置插入元素 pop 删除指定下标元素 remove 删除某个元素，元素需要在列表中，否则会报错 reverse 反转列表 sort 对列表进行排序 二、元组元组与列表的区别在于：1. 元组不能对其元素进行变动，而列表可以。2. 元组用（）括起来，而列表用[]括起来 元组的声明 简单版 1234#声明一个空元组tuple=()#简单声明一个元组tuple1=('name','age') 进阶版 1234#省略（）的元组name,age='chengyan',18person=(name,age)print(person) 元组的基本操作 方法名称 方法功能描述 count 统计指定元素的个数 index 返回指定元素的下标 函数名称 函数功能描述 len 统计元组元素个数 max 返回元组中最大值的元素 min 返回元组中最小值的元素 tuple 将列表转换为元组 type 返回对象类型 del 删除整个元组对象 sum 对元组所有元素求和 三、字典 创建字典 1dic={'name':'chengyan','age':18} 字典的常用方法 方法名称 方法功能描述 clear 字典清空 copy 复制生成另一个字典 fromkeys 使用给定的key建立新的字典，值默认为None get 返回key对应的值 items 以元组数组的方式返回字典中的元素 keys 以列表的形式返回字典中的keys pop 删除指定键的值，并返回该值 popitem 随机返回元素，并删除元素，以元组的形式 setdefault 当字典中的键不存在的时候，设置值，如存在时，返回对应的值 update 利用一个字典去更新另外一个字典 values 返回字典中的值 一些示例 12345678910111213141516171819202122232425262728dic={'name':'chengyan'}#新增元素dic['age']=18#如果没有，设置默认值，有，不做操作dic.setdefault('name','wangqi')#查询name = dic['name']name = dic.get('name')#修改dic['name']='wangqi'dic.update('name','wangqi')#删除dic.pop('name')del(dic['name'])#随机删除一个并返回该元组dic.popitem()#遍历for tuple in dic: print(tuple)for key in dic: print(key)for key in dic: print(dic[key])#fromkeys方式创建字典dic1={}.fromkeys['name','age','class','school'] 四、小结这一节，基本了解了元组、列表、字典的创建、以及一些常用的方法。下节学习下函数，see u","link":"/2019/10/17/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"Python结合cocoapod自动发布版本实践","text":"一、问题ios开发人员可能对cocoapod比较熟悉，在维护个人的cocoapod版本的时候，会遇到一个问题，那么就是本地代码库修改了文件，一般需要做如下三步操作 代码功能开发完毕，提交代码到git服务器 修改.podspec文件中的版本号 给对应的提交打上tag，以便pod发布时需要 使用pod trunk push 命令，发布到cocoapod 步骤比较多，修改版本和打tag，有时候容易遗漏，如果发布失败的话，还需要重新再修改版本，打tag。很浪费时间，基于此，结合我最近研究的python，写了一个脚本。来实现一键提交代码、发布pod库的功能 二、脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#encoding:utf-8#!usr/bin/pythonimport osf = open(&quot;CYKit.podspec&quot;, &quot;r+&quot;)print (&quot;文件名为: &quot;, f.name) shouldModifire = '' content = ''for line in f.readlines(): #依次读取每行 content = content + line line = line.strip() #去掉每行头尾空白 if 's.version = &quot;0' in line: shouldModifire = line #查找到需要修改的行print('shouldModifire%s'%shouldModifire)items = shouldModifire.split('=')print(items)versions = items[1].split('.')versions_last_length = len(versions[2])versions_last = int(versions[2][:versions_last_length-1])versions_last_int = (versions_last) + 1newVersion = str(versions[0])+'.'+ str(versions[1]) + '.' + str(versions_last_int) + '&quot;'shouldReplaceItem = items[0] + '=' + newVersion#替换相应的版本号，并写入文件replaceed = content.replace(shouldModifire,shouldReplaceItem)print('修改版本号:' + shouldModifire + '=&gt;' + shouldReplaceItem)#写入文件f.seek(0)f.truncate() f.write(replaceed)f.flush()#关闭文件f.close()#代码提交os.system('git add .')os.system('git commit -a -m &quot;【脚本】修改相应版本号&quot;')os.system('git push origin master')os.system('git tag -a ' + newVersion + ' -m ' + 'tag版本号')os.system('git push --tags')#提交到cocoapodsos.system('pod trunk push --allow-warnings') 三、遇到的问题总体来说开发还算顺利，唯一卡壳的地方就是，读取本地文件，修改里面的版本号，这里使用了暴力的写文件方式。 好了，又可以开心的撸代码了，see u","link":"/2019/10/18/Python%E7%BB%93%E5%90%88cocoapod%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E7%89%88%E6%9C%AC%E5%AE%9E%E8%B7%B5/"},{"title":"ReactNative学习一-RN的技术栈","text":"基础知识下面这张图是极客时间讲师：蒋宏伟总结的RN需要的基础知识 从上到下，分为： 开发语言，框架，工具等基础 RN的知识，主要是组件的学习 实践 React框架基于组件React是在 2013 年正式开始开源的。在此之前，业内的大多数 Web 框架都是 MVC 框架。 MVC 框架解决了代码大杂烩的问题，它把代码分成了职责分明的三层，M 指的是数据模型 Modal，V 指的视图模板 View，C 指的是控制器 Controller。MVC 强调的是数据、视图和逻辑之间松耦合，其文件结构也是按这三类分门别类地组织起来的。 声明式声明式编程是一个大的概念，除了我们前面提到了 HTML 所属的领域专属语言（DSL）之外，还有函数式编程等子编程范式。熟悉 React 的同学可能就知道了，React 借鉴了大量的函数式编程的思想。核心基础篇中的函数组件、hook，还有我们后面要讲的状态管理工具 Redux 和新架构原理，都大量使用了函数式编程的思想 核心组件的样式 Image Pressable TextInput List 以上面四个组件为例，学习组件的样式 项目实践实践才能将所学的知识彻底夯实成为自己的技能。","link":"/2022/07/26/ReactNative%E5%AD%A6%E4%B9%A0%E4%B8%80-RN%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"title":"ReactNative学习三:样式Style","text":"前言组件只是页面的架子，如果不使用样式，就会平铺在页面上，没有什么体验可言。 React Native的组件样式有哪些?React Native的Flex布局有哪些特点?React Natice的样式代码怎么管理? 一、组件样式1.1 通用样式大部分的React组件都有样式属性，style，例如改变文字 1234// 文字颜色&lt;Text style={{color:'red'}}&gt;// 圆角边框&lt;Text style={{borderColor:'gray',borderWidth:1,borderRadius:5}}&gt; 下图是常见的通用样式和组件样式的一些继承关系 1.2 私有样式View的样式，可以认为是通用样式，如Layout、Transform、Shadow、backgroundColor、opacity。像Text、Image、除了继承自View的通用样式以外，还有如font、color、lineHeight等等这些样式，都可以认为是私有样式 二、Flex弹性布局 跨平台 第一层含义是 Flex 布局并不是 React Native 所独有的，在 Web、Android、iOS 平台也都在用 跨平台的第二层含义是，React Native 的布局引擎 Yoga 是 Android、iOS 通用的 高性能 使用 Yoga 实现的 FlexLayout 布局引擎比苹果官方提供了 UIStackViews 和 Auto layout 布局引擎，耗时减少了将近一个量级 易上手 从上往下的布局样式，父容器view默认是{display:&quot;flex&quot;,flexDirection:'column'}。示例如下：12345&lt;View&gt;&lt;View style={{height: 50, backgroundColor: 'powderblue'}} /&gt;&lt;View style={{height: 50, backgroundColor: 'skyblue'}} /&gt;&lt;View style={{height: 50, backgroundColor: 'steelblue'}} /&gt;&lt;/View&gt; 左图右文布局。123456789&lt;View style={{flexDirection: 'row'}}&gt; &lt;Image style={{width: 100, height: 100}} source={{ uri: 'https://placeimg.com/640/480/cats', }} /&gt; &lt;Text style={{flex: 1,fontSize: 18}}&gt;我是文字&lt;/Text&gt;&lt;/View&gt; 文字居中布局 12345678910111213141516171819&lt;View style={{ alignItems: 'center', justifyContent: 'center', // 高度确定 height: 60, borderWidth: 1, }}&gt; &lt;Text style={{ fontSize: 18, // 文字默认内边距，会导致垂直居中偏下 includeFontPadding: false, // 文字默认基于基线对齐，会导致垂直居中偏下 textAlignVertical: 'center', }}&gt; 我是文字1 &lt;/Text&gt;&lt;/View&gt; 三、StyleSheet3.1 使用Stylesheet的好处。 元素结构和样式分离、可维护性好 样式对象可以复用，减少重复代码 样式代码只创建一次，减少性能的损耗3.2 没有使用stylesheet的样式12345678910111213141516171819202122232425262728293031323334353637// 各种内联，导致 JSX 结构不清楚。&lt;View // 普通属性 hitSlop={ top: 10, bottom: 10, left: 0, right: 0 } // 事件属性 onLayout={() =&gt; { // 事件逻辑 }} // 样式属性 style={{ alignItems: 'center', justifyContent: 'center', height: 60, borderWidth: 1, }}&gt; &lt;Text style={{ fontSize: 18, includeFontPadding: false, textAlignVertical: 'center', }}&gt; 我是文字1 &lt;/Text&gt; &lt;Text style={{ fontSize: 18, includeFontPadding: false, textAlignVertical: 'center', }}&gt; 我是文字2 &lt;/Text&gt;&lt;/View&gt; 3.3 使用StyleSheet的样式代码123456789101112131415161718192021222324// JSX 结构&lt;View hitSlop={hitSlop} onLayout={handleLayout} style={styles.container}&gt; &lt;Text style={styles.texts}&gt;我是文字1&lt;/Text&gt; &lt;Text style={styles.texts}&gt;我是文字2&lt;/Text&gt;&lt;/View&gt;// 样式表const styles = StyleSheet.create({ container: { alignItems: 'center', justifyContent: 'center', height: 60, borderWidth: 1, }, texts: { fontSize: 18, includeFontPadding: false, textAlignVertical: 'center', }});","link":"/2022/07/29/ReactNative%E5%AD%A6%E4%B9%A0%E4%B8%89-%E6%A0%B7%E5%BC%8FStyle/"},{"title":"ReactNative学习二-Component","text":"搭建静态页面的原则单一责任原则每个组件都应该只有一个单一的功能，并且这个组件和其他组件没有相互依赖 分析一段代码来学习一个组件的基本构成 12345678export default function Product({product = {name: '苹果', price: '1元'} }) { return ( &lt;View style={{flexDirection: 'row', marginTop: 5}}&gt; &lt;Text style={{flex: 1}}&gt;{product.name}&lt;/Text&gt; &lt;Text style={{width: 50}}&gt;{product.price}&lt;/Text&gt; &lt;/View&gt; );} 第一步，导出组件。还记得单一责任原则吗？一个组件的责任要单一，一个文件的责任也要单一。因此通常一个文件中只有一个组件，用export default就可以将它导出，让其他文件import引入使用。 第二步，定义函数。组件是一种特殊的函数。组件名字的首字母一定是大写的，示例中的Product是组件，因此它的 P是大写的（当然，还有类组件，但用得会越来越少，这里我们不探讨，你可以自己额外搜些资料）。 第三步，接收入参。组件能从其父组件中接参数，而且组件是函数，因此该参数就是函数的入参，通常命名为属性 props。props 是一个对象，因此也可以直接对它进行解构，直接获取对象中的值。示例代码中用的就是用解构的方式来获取参数的，它直接获取了product参数，这里的product 是数据因此p是小写的。 第四步，返回 JSX。组件的返回值就是 JSX，我们前面也提到过，它是用来描述 UI 页面的，JSX 最终生成的是视图元素、文字元素。这里我们初始化了一个元素，和两个元素。 组件的文件结构123456789101112131415161718192021222324252627282930313233343536// index.jsAppRegistry.registerComponent('appName', () =&gt; App);// App.jsconst PRODUCTS = [ {category: '水果', price: '￥1', name: 'PingGuo'},];export default function App() { return ( &lt;SafeAreaView style={{marginHorizontal: 30}}&gt; &lt;ProductTable products={PRODUCTS} /&gt; &lt;/SafeAreaView&gt; );}// ProductTable.jsimport Category from './Category';import Product from './Product';export default function ProductTable({products}){ // ... &lt;Category category={products[i].category} // ... &lt;Product product={products[i]} // ... }// Category.jsexport default function Category({category}){}// ProductTable.jsexport default function Product({product}) {} index.js 文件：它是根文件，在该文件中registerComponent方法，会调用根组件 App，然后开始逐级调用，渲染应用； App 组件：在 App 组件中，用于表示商品信息的数据变量 PRODUCTS，在被调用时会通过 ProductTable 组件的 products 属性传递下去； ProductTable 组件：它被 App 组件调用后，它的调用入参就是 products。products 是一个数组，数组中的每一项就是 Product组件的入参product。每一项中的分类，就是Category 组件的入参 category。还是一样，组件首字母是大写的，属性、入参的首字母是小写的； Category 组件：它会被 ProductTable 组件调用两次，第一次调用接收的入参category是“水果”，第二次是“蔬菜”； Product 组件：它会被 ProductTable 组件调用 6 次，生成 6 个不同的商品元素，展示在手机屏幕上。 简而言之，组件间的数据是单向流动的，是逐层往下传递","link":"/2022/07/27/ReactNative%E5%AD%A6%E4%B9%A0%E4%BA%8C-Component/"},{"title":"ReactNative学习四:State","text":"如何让页面动起来？如图是一个简单的购物车页面的UI，分别用来展示商品的名称、价格和数量。 选择状态这个页面需要一个标示页面请求正常or失败的状态，这里使用枚举值 123456const RequestStatus = { IDLE = 'IDLE', PENDING = 'PENDING', SUCCESS = 'SUCCESS', ERROR = 'ERROR'} 此外还需要一个列表对象用来展示数据,采用 1const [products, setProduct] = useState([]); 即一个枚举和一个数组来展示页面。 状态更新基础数据类型的状态更新还是看下面的代码，以更新数量为例，首先注册了状态 “count”,然后在组件的返回函数里面，通过按钮的点击事件，调用setCount(count+1)，来达到更新count值的效果。 12345678910export default function count(){ const [count ,setCount] = useState(0); return { &lt;View&gt; &lt;Text&gt;{count}&lt;/Text&gt; &lt;Button title=&quot;+&quot; onPress={()=&gt;setCount(count + 1)}&gt;&lt;/Button&gt; &lt;Button title=&quot;-&quot; onPress={()=&gt;setCount((count-1)&gt;0? count-1 : 0)}&gt; &lt;/View&gt; };} 引用数据类型的状态更新引用数据类型的更新， 需要先析构原数据对象，然后再重新赋值，才可达到更新的效果，对象析构的写法...countObjects 12345setCountObject({...countObject, num: countObject.num+1});const newCountArray = [...newCountArray]newCountArray[0]++;setCountArray(newCountArray) 加载图片 使用方法 底层scheme 使用建议 使用场景 静态图片资源 require(‘./dianxin’) file// 跟随bundle压缩包下发 关键图片 网络图片 {uri:’https://cdn.dianxin.com/..,.png'} http 或 https 自研图片管理工具 大部分场景 宿主应用图片 uri:’dainxin’ file://或 asset:// 不建议 复用场景 Base64图片 ‘uri’:’data:image/jpeg,base64…..’ data:mime/type;base64 自研图片管理工具 小图或者关键图","link":"/2022/07/29/ReactNative%E5%AD%A6%E4%B9%A0%E5%9B%9B-State/"},{"title":"ReactNative新架构分享","text":"RN的前世今生123React Native是2013年在facebook的内部黑客马拉松中诞生的。到今年2022年新架构，已经整整10年。 ### RN适用什么场景 * 业务更新迭代较快的团队与出海团队。 * 既要支持动态更新，又要支持复杂业务的场景。 为什么要学习 React Native ？ React Native 是一个非常流行的跨端框架，开发者认可度很高 2. React Native 是一个跨领域的融合技术，它是你现有技术的自然延伸。3. 更为重要的是，今年RN将会发布新架构。新架构将带来以下三个方面的优势 React Native 新架构的启动性能会有 2 倍左右的提升。 React Native 新架构的通信性能会有 3 倍左右的提升。 React Native 新架构的渲染流水有了很大的变化，这会带来更好的用户体验。 RN的技术栈下图是RN会涉及到的知识图谱 序号 内容 1 开发语言、React 框架、开发必备工具这些预备知识 2 React Native 本身的知识， 组件等 3 工作流中的实操知识 如何搭建一个RN页面RN是基于组件来构建应用的，所以构成页面的最小元素是即是组件. 基本原则UI稿拆分原则:单一责任原则 搭建元素 通过宿主组件来承载UI稿上面的元素，这些宿主组件包括文本、图片、按钮、列表等等呢个，这些组件都是直接由iOS/Andriod原生平台生成的 整体思路是，从上往下拆出组件，从下往上把拆出来的组件进行逐一实现和拼装 RN的样式 通用样式 view组件样式 其他样式 1234// 文字颜色&lt;Text style={{color:'red'}}&gt;// 圆角边框 &lt;Text style={{borderColor:'green', borderWidth: 1, borderRadius: 5}}&gt; 如何布局？？Flex：跨平台、高性能、易上手 内联样式和样式表， stylessheet的三个好处 元素结构和样式分离，可维护性更好； 样式对象可以复用，能减少重复代码； 样式对象只创建一次，也减少性能的损耗。 动态页面RN的页面，用宿主组件搭建完成之后，还是一个静态的页面，如果要让页面展示不同的内容，还需要使用UseState()来进行页面的刷新,下面的代码是一个简单的控制数量的组件 12345678910export default function Count() { const [count, setCount] = useState(0); return ( &lt;View&gt; &lt;Text&gt;{count}&lt;/Text&gt; &lt;Button title=&quot;+&quot; onPress={() =&gt; setCount(count + 1)} /&gt; &lt;Button title=&quot;-&quot; onPress={() =&gt; setCount(count - 1 &gt;=0? count - 1: 0)} /&gt; &lt;/View&gt;)}; 图片的加载 静态图片加载 123// 方案一：正确const dianxinIcon = require('./dianxin.jpg')&lt;Image source={dianxinIcon}/&gt; 网络图片加载 123// 建议&lt;Image source={{uri: 'https://reactjs.org/logo-og.png'}} style={{width: 400, height: 400}} /&gt; base64图片加载 12345&lt;Image source={{ uri: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAzCAYAAAA6oTAqAAAAEXRFWHRTb2Z0d2FyZQBwbmdjcnVzaEB1SfMAAABQSURBVGje7dSxCQBACARB+2/ab8BEeQNhFi6WSYzYLYudDQYGBgYGBgYGBgYGBgYGBgZmcvDqYGBgmhivGQYGBgYGBgYGBgYGBgYGBgbmQw+P/eMrC5UTVAAAAABJRU5ErkJggg==' }}/&gt; 宿主应用图片 123// Android drawable 文件目录// iOS asset 文件目录&lt;Image source={{ uri: 'app_icon' }} /&gt;","link":"/2022/08/22/ReactNative%E6%96%B0%E6%9E%B6%E6%9E%84%E5%88%86%E4%BA%AB/"},{"title":"SDWebImage学习笔记（一）","text":"简介SDWebImage是ios开发中，最常见的图片加载框架，它主要实现了图片异步加载、图片缓存，并提供了UIImageView、UIButton、MKAnnotationview的类目，使用体验很友好，也很方便，成为广大ios开发者加载网络图片的选择，今天我主要是来通过分析其源码来研究下，SDWebimage到底是如何进行设计的，架构的? 特性 提供UIimageview、UIbutton、MKAnnotationview的类目加载网络图片及缓存管理 异步的图片下载 异步的图片内存+磁盘图片缓存，并支持自动的缓存过期处理 图片的后台解压 确保同一个url不会下载多次（是优点也是缺点） 错误的url不会不停的下载 永远不会阻塞主线程 性能提升 采用GCD和ARC 支持的图片格式 支持JPEG,PNG,GIF 支持WEBP 使用要求 ios 7.0 + tvos 9.0 + watchos 2.0 + osx 10.8 + xcode 7.3 + 常见问题 如果UITableViewCell使用了动态的图片大小，图片展示可能会有问题，也就是说SDWebImage是根据placeholder的大小来设置UIImageView的大小的，如果要展示的图片大小和placeholder的图片大小不一致就会有一些问题，解决方案点击这里 手动去刷新图片，SDWebImage使用了暴力的图片缓存方式，不会关注HTTP 的header里面缓存的策略，直接根据图片的URL地址进行缓存，也就是说一个URL会对应一张图片，如果图片地址不发生变化的话，图片永远不会重新下载，因此在某些场景下，你需要手动去刷新图片。 架构图 正文上文是SDWebImageView官方的一些文档，我这里给简要的翻译了下，可以看的出来，SDWebImage虽然功能很强大，但是依然还是有一些使用中存在的问题。接下来，我将会通过逐个分析代码的方式，将SDWebImageView从下载、缓存、管理等等一层一层剥开它神秘的面纱。在这个过程中，我尽量避免过多的纠结于一些细节，但是同样的，有些时候为了说明一些问题，难免也会贴一些代码。 下载SDWebimageview的下载是通过NSURLSession的方式，并通过继承NSOperation来异步的进行下载。下载过程中是通过发送通知的方式进行消息通信。 1234NSString *const SDWebImageDownloadStartNotification = @&quot;SDWebImageDownloadStartNotification&quot;;NSString *const SDWebImageDownloadReceiveResponseNotification = @&quot;SDWebImageDownloadReceiveResponseNotification&quot;;NSString *const SDWebImageDownloadStopNotification = @&quot;SDWebImageDownloadStopNotification&quot;;NSString *const SDWebImageDownloadFinishNotification = @&quot;SDWebImageDownloadFinishNotification&quot;; SDWebImageDownloaderOperation任务的创建及取消 SDWebImageDownloaderOperation通过确认下面的这俩个协议实际上执行下载图片的工作，接下来就研究下其内部是怎么工作的。 123456789101112131415161718192021222324@protocol SDWebImageDownloaderOperationInterface&lt;NSObject&gt;//通过该方法进行Opearation的创建- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request inSession:(nullable NSURLSession *)session options:(SDWebImageDownloaderOptions)options;//添加下载过程中需要的回调，主要包括下载进度、下载完成的回调- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;//是否支持解压图片- (BOOL)shouldDecompressImages;//设置是否支持解压图片- (void)setShouldDecompressImages:(BOOL)value;//URL鉴定- (nullable NSURLCredential *)credential;//设置URL鉴定- (void)setCredential:(nullable NSURLCredential *)value;@end@protocol SDWebImageOperation &lt;NSObject&gt;- (void)cancel;@end SDWebImageDownloaderOperation任务的初始化以及任务的执行忽略掉那些细节，这里只关注关键的几个地方，SDWebImageDownloaderOperation，以下简称‘下载操作对象’，通过持有Request，注入session，以及options，创建好下载操作对象。之后通过外部调用start方法，开启下载任务。并通过设置session任务的代理，来监听下载过程，同时发出相应的通知进行对象间的消息通信。 初始化1234567891011121314151617- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request inSession:(nullable NSURLSession *)session options:(SDWebImageDownloaderOptions)options { if ((self = [super init])) { _request = [request copy]; _shouldDecompressImages = YES; _options = options; _callbackBlocks = [NSMutableArray new]; _executing = NO; _finished = NO; _expectedSize = 0; _unownedSession = session; responseFromCached = YES; // Initially wrong until `- URLSession:dataTask:willCacheResponse:completionHandler: is called or not called _barrierQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageDownloaderOperationBarrierQueue&quot;, DISPATCH_QUEUE_CONCURRENT); } return self;} 执行任务12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576- (void)start { @synchronized (self) { if (self.isCancelled) { self.finished = YES; [self reset]; return; }#if SD_UIKIT Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;); BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)]; //对后台下载任务的支持，app可以开启后台下载任务，并返回一个后台下载的ID，并设置一个过期的callback，此处注意当任务失效的时候，需要将任务终止，并设置taskid为无效 if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) { __weak __typeof__ (self) wself = self; UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)]; self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^{ __strong __typeof (wself) sself = wself; if (sself) { [sself cancel]; [app endBackgroundTask:sself.backgroundTaskId]; sself.backgroundTaskId = UIBackgroundTaskInvalid; } }]; }#endif //默认是有注入session，如果没有的话，需要内部创建一个session NSURLSession *session = self.unownedSession; if (!self.unownedSession) { NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration]; sessionConfig.timeoutIntervalForRequest = 15; /** * Create the session for this task * We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate * method calls and completion handler calls. */ self.ownedSession = [NSURLSession sessionWithConfiguration:sessionConfig delegate:self delegateQueue:nil]; session = self.ownedSession; } //此处根据当前的session和request创建datatask self.dataTask = [session dataTaskWithRequest:self.request]; self.executing = YES; } //datatask开始工作 [self.dataTask resume]; if (self.dataTask) { //通知所有监听回调，任务开始执行了。俩种方式，一种是callback方式，一种是通知 for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) { progressBlock(0, NSURLResponseUnknownLength, self.request.URL); } dispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self]; }); } else { //对异常情况的处理，如果datatask为nil，进行错误的回调 [self callCompletionBlocksWithError:[NSError errorWithDomain:NSURLErrorDomain code:0 userInfo:@{NSLocalizedDescriptionKey : @&quot;Connection can't be initialized&quot;}]]; }#if SD_UIKIT Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;); if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) { return; } if (self.backgroundTaskId != UIBackgroundTaskInvalid) { UIApplication * app = [UIApplication performSelector:@selector(sharedApplication)]; [app endBackgroundTask:self.backgroundTaskId]; self.backgroundTaskId = UIBackgroundTaskInvalid; }#endif} 接下来就是NSURLSession任务的开启、执行中、结束或者错误回调这里就不去贴代码了，要不然这篇博文很大篇幅都被代码占据了，其实任务执行开始之后，主要就是各种异常的处理，因为正常的处理其实是比较简单的，之后就会回调到外面去，让外面调用‘下载操作对象’去决定到底该如何处理。（补充：经过后面对SDWebImageDownloader的深入研究，发现SDWebImageDownloaderOperation创建好之后，直接扔到SDWebImageDownloader的队列里面去了，此外session由于是注入的，代理设置的是SDWebImageDownloader，回调自然也由SDWebImageDownloader接收，然后分发给各自对应的SDWebImageDownloaderOperation） SDWebImageDownloader对下载任务的封装SDWebImageDownloader是对SDWebImageDownloaderOperation的进一步管理和封装，通过下载队列对SDWebImageDownloaderOperation的任务并发数(默认并发数为6个)，执行顺序（默认是FIFO）进行管理。这里我简单梳理下任务的下载流程 client（此处指的是使用SDWebImageDownloader的客户，可以是用户自己的类，也可以是其他SDWebImage类）首先需要创建一个SDWebImageDownloader，创建好之后，就准备好了下载需要的downloadQueue，下载相关的一些配置（诸如执行顺序、并发数、超时等等）。 client之后调用SDWebImageDownloader的downloadImageWithURL:options:progress:completed:进行实际的下载操作。在这里我有一个疑惑了好久的问题，就是session的回调问题，因为SDWebImageDownloaderOperation里面有session，而SDWebImageDownloader也有session，那么任务执行过程中，岂不是俩处都会收到回调？这难道是SDWebImage的BUG？呵呵，其实并不是，直到我看到下面这段代码。123456789101112131415161718NSURLSession *session = self.unownedSession;if (!self.unownedSession) { NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration]; sessionConfig.timeoutIntervalForRequest = 15; /** * Create the session for this task * We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate * method calls and completion handler calls. */ //注意这里，只有ownedSession才会设置代理为自己，也就是说注入的session不会设置代理。 self.ownedSession = [NSURLSession sessionWithConfiguration:sessionConfig delegate:self delegateQueue:nil]; session = self.ownedSession;}self.dataTask = [session dataTaskWithRequest:self.request]; 看了上面的代码自然就明白了，当使用SDWebImageDownloader的时候，session的回调只有SDWebImageDownloader能接收到，这也是为什么SDWebImageDownloader需要在接收到回调之后要进行转发的缘故。 SDWebImageDownloader的初始化1234567891011121314151617181920212223242526272829303132- (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)sessionConfiguration { if ((self = [super init])) { _operationClass = [SDWebImageDownloaderOperation class]; _shouldDecompressImages = YES; //设置任务的执行顺序 _executionOrder = SDWebImageDownloaderFIFOExecutionOrder; //创建执行任务的操作队列，并对操作队列进行配置 _downloadQueue = [NSOperationQueue new]; _downloadQueue.maxConcurrentOperationCount = 6; _downloadQueue.name = @&quot;com.hackemist.SDWebImageDownloader&quot;; _URLOperations = [NSMutableDictionary new];#ifdef SD_WEBP _HTTPHeaders = [@{@&quot;Accept&quot;: @&quot;image/webp,image/*;q=0.8&quot;} mutableCopy];#else _HTTPHeaders = [@{@&quot;Accept&quot;: @&quot;image/*;q=0.8&quot;} mutableCopy];#endif _barrierQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageDownloaderBarrierQueue&quot;, DISPATCH_QUEUE_CONCURRENT); _downloadTimeout = 15.0; sessionConfiguration.timeoutIntervalForRequest = _downloadTimeout; /** * Create the session for this task * We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate * method calls and completion handler calls. */ self.session = [NSURLSession sessionWithConfiguration:sessionConfiguration delegate:self delegateQueue:nil]; } return self;} SDWebImageDownloader执行下载操作这里请原谅我贴上大段的代码，因为这段代码实在是太漂亮了。通过俩个函数的设计将SDWebImageDownloaderOperation的初始化和SDWebImageDownloadToken初始化分割开。并在初始化operation完成之后将任务扔到队列中去执行，还持有了operation的引用，给SDWebImageDownloader有机会保存到字典中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock { __weak SDWebImageDownloader *wself = self; return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *{ __strong __typeof (wself) sself = wself; NSTimeInterval timeoutInterval = sself.downloadTimeout; if (timeoutInterval == 0.0) { timeoutInterval = 15.0; } // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval]; request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies); request.HTTPShouldUsePipelining = YES; if (sself.headersFilter) { request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders copy]); } else { request.allHTTPHeaderFields = sself.HTTPHeaders; } SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options]; operation.shouldDecompressImages = sself.shouldDecompressImages; if (sself.urlCredential) { operation.credential = sself.urlCredential; } else if (sself.username &amp;&amp; sself.password) { operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession]; } if (options &amp; SDWebImageDownloaderHighPriority) { operation.queuePriority = NSOperationQueuePriorityHigh; } else if (options &amp; SDWebImageDownloaderLowPriority) { operation.queuePriority = NSOperationQueuePriorityLow; } [sself.downloadQueue addOperation:operation]; if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) { // Emulate LIFO execution order by systematically adding new operations as last operation's dependency [sself.lastAddedOperation addDependency:operation]; sself.lastAddedOperation = operation; } return operation; }];} 这里有对SDWebImageDownloaderOperation进行保存处理，确保同一个URL只会创建一次，避免内存的额外消耗。添加对token的初始化和管理，把operation的初始化和token的初始化进行业务上一些小分离，代码层次立马清晰起来了，赞！ 1234567891011121314151617181920212223242526272829303132333435363738- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(nullable NSURL *)url createCallback:(SDWebImageDownloaderOperation *(^)())createCallback { // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data. if (url == nil) { if (completedBlock != nil) { completedBlock(nil, nil, nil, NO); } return nil; } __block SDWebImageDownloadToken *token = nil; dispatch_barrier_sync(self.barrierQueue, ^{ SDWebImageDownloaderOperation *operation = self.URLOperations[url]; if (!operation) { operation = createCallback(); self.URLOperations[url] = operation; __weak SDWebImageDownloaderOperation *woperation = operation; operation.completionBlock = ^{ SDWebImageDownloaderOperation *soperation = woperation; if (!soperation) return; if (self.URLOperations[url] == soperation) { [self.URLOperations removeObjectForKey:url]; }; }; } id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]; token = [SDWebImageDownloadToken new]; token.url = url; token.downloadOperationCancelToken = downloadOperationCancelToken; }); return token;} 小结 好了，SDWebImageView的下载环节就到这里，看来那句话确实没说错，源码面前，没有神秘，哈哈！下一小节主要研究下SDWebImageView是如何对图片进行缓存操作的。 参考资料[1]. SDWebimage在github上的地址[2]. 英文版的使用说明[3]. 使用SDWebimage的app列表","link":"/2016/12/30/SDWebImage%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"SDWebImage学习笔记（三）","text":"上一小节研究了SDWebImageView里面的缓存实现原理，在这一小节我们继续研究SDWebImage对缓存和下载整体功能的封装。也就是-SDWebImageManager管理类。 组装SDWebImageManager使用了组装的设计模式，通过内部包含SDWebImageCache和SDWebImageDownloader的成员变量来实现下载和缓存的功能。 123@interface SDWebImageManager : NSObject@property (strong, nonatomic, readonly, nullable) SDImageCache *imageCache;@property (strong, nonatomic, readonly, nullable) SDWebImageDownloader *imageDownloader; 接入，下载和缓存对象可以由初始化的时候外部传入，但是官方建议的还是在SDWebImageManager初始化的时候进行初始化。 123456789101112131415161718192021222324+ (nonnull instancetype)sharedManager { static dispatch_once_t once; static id instance; dispatch_once(&amp;once, ^{ instance = [self new]; }); return instance;}- (nonnull instancetype)init { SDImageCache *cache = [SDImageCache sharedImageCache]; SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader]; return [self initWithCache:cache downloader:downloader];}- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader { if ((self = [super init])) { _imageCache = cache; _imageDownloader = downloader; _failedURLs = [NSMutableSet new]; _runningOperations = [NSMutableArray new]; } return self;} 代理SDWebImageManager使用了代理的设计模式，给使用者提供一个可以过滤下载URL和对下载后的图片进行转码的一个外部接口，代码如下： 12345678910111213141516171819202122232425262728@protocol SDWebImageManagerDelegate &lt;NSObject&gt;@optional/** * 控制图片是否允许被下载，当这个图片在缓存中没找到时候 * * @param imageManager 图片管理器 * @param imageURL 要下载的图片URL * * @return 返回NO，当缓存没有命中的时候，阻止图片下载。如果没实现，默认是YES * */- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldDownloadImageForURL:(nullable NSURL *)imageURL;/** * 允许转变图片，当图片被从网上下载下来，但是还没有缓存到磁盘和内存中之前。 * NOTE: 这个方法是在全局的队列中调用的。以防对主线程造成阻塞 * * @param imageManager The current `SDWebImageManager` * @param image The image to transform * @param imageURL The url of the image to transform * * @return The transformed image object. */- (nullable UIImage *)imageManager:(nonnull SDWebImageManager *)imageManager transformDownloadedImage:(nullable UIImage *)image withURL:(nullable NSURL *)imageURL;@end 核心API外部唤起下载操作 SDWebImageManager提供了一个外部传入URL和SDWebImageOptions，而后可以获取下载过程回调，以及下载完成回调的一个核心API，该核心API会返回一个确认SDWebImageOperation协议的对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock { // 如果完成回调没有设置，用断言直接打断 NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;); // 如果是误传了NSString类型到NSURl，做容错处理 if ([url isKindOfClass:NSString.class]) { url = [NSURL URLWithString:(NSString *)url]; } // 容错 if (![url isKindOfClass:NSURL.class]) { url = nil; } // 操作对象 __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new]; __weak SDWebImageCombinedOperation *weakOperation = operation; // 验证是否是错误的URL BOOL isFailedUrl = NO; if (url) { @synchronized (self.failedURLs) { isFailedUrl = [self.failedURLs containsObject:url]; } } // 当确认是错误的URL取消操作 if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) { [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil] url:url]; return operation; } // 如果往下走了，证明是正确的URL，把请求操作保存到数组中 @synchronized (self.runningOperations) { [self.runningOperations addObject:operation]; } // 获取缓存的key NSString *key = [self cacheKeyForURL:url]; // 使用内部创建的图片缓存类，创建缓存操作 operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) { // 操作被取消，将operation从内部的数组中移除，block终止 if (operation.isCancelled) { [self safelyRemoveOperationFromRunning:operation]; return; } // 处理不存在缓存图片或有缓存但是需要重新刷新的情况 if ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) { if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) { // 如果图片在缓存中，但是选项要求重新下，那么直接调用重新下 [self callCompletionBlockForOperation:weakOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; } // 如果没有缓存图片，那就踏踏实实下载吧，先设置下载选项 SDWebImageDownloaderOptions downloaderOptions = 0; if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority; if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload; if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache; if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground; if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies; if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates; if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority; if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages; // 如果有缓存图片且是要求强制刷新的情况，那就强制刷新 if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) { // force progressive off if image already cached but forced refreshing downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload; // ignore image read from NSURLCache if image if cached but force refreshing downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse; } // 下载引擎执行下载操作 SDWebImageDownloadToken *subOperationToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) { __strong __typeof(weakOperation) strongOperation = weakOperation; if (!strongOperation || strongOperation.isCancelled) { // Do nothing if the operation was cancelled // See #699 for more details // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data } else if (error) { // 下载错误了，进行错误回调，并将错误的url存到错误url数组中 [self callCompletionBlockForOperation:strongOperation completion:completedBlock error:error url:url]; if ( error.code != NSURLErrorNotConnectedToInternet &amp;&amp; error.code != NSURLErrorCancelled &amp;&amp; error.code != NSURLErrorTimedOut &amp;&amp; error.code != NSURLErrorInternationalRoamingOff &amp;&amp; error.code != NSURLErrorDataNotAllowed &amp;&amp; error.code != NSURLErrorCannotFindHost &amp;&amp; error.code != NSURLErrorCannotConnectToHost) { @synchronized (self.failedURLs) { [self.failedURLs addObject:url]; } } } else { // 如果选项是下载错误继续下，将错误url从错误数组中移除 if ((options &amp; SDWebImageRetryFailed)) { @synchronized (self.failedURLs) { [self.failedURLs removeObject:url]; } } // 获取缓存设置 BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly); if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) { // Image refresh hit the NSURLCache cache, do not call the completion block } else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) { dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url]; if (transformedImage &amp;&amp; finished) { BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage]; // pass nil if the image was transformed, so we can recalculate the data from the image [self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil]; } [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; }); } else { if (downloadedImage &amp;&amp; finished) { [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil]; } [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; } } if (finished) { [self safelyRemoveOperationFromRunning:strongOperation]; } }]; operation.cancelBlock = ^{ [self.imageDownloader cancel:subOperationToken]; __strong __typeof(weakOperation) strongOperation = weakOperation; [self safelyRemoveOperationFromRunning:strongOperation]; }; } else if (cachedImage) { __strong __typeof(weakOperation) strongOperation = weakOperation; [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; [self safelyRemoveOperationFromRunning:operation]; } else { // Image not in cache and download disallowed by delegate __strong __typeof(weakOperation) strongOperation = weakOperation; [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url]; [self safelyRemoveOperationFromRunning:operation]; } }]; return operation;} 取消所有请求将正在运行的操作全部执行取消操作，并将操作从执行数组中移除 12345678- (void)cancelAll { // 注意要加锁 @synchronized (self.runningOperations) { NSArray&lt;SDWebImageCombinedOperation *&gt; *copiedOperations = [self.runningOperations copy]; [copiedOperations makeObjectsPerformSelector:@selector(cancel)]; [self.runningOperations removeObjectsInArray:copiedOperations]; }} 检测是否在运行辅助方法，检测是否有请求在运行中 1234567- (BOOL)isRunning { BOOL isRunning = NO; @synchronized (self.runningOperations) { isRunning = (self.runningOperations.count &gt; 0); } return isRunning;} 缓存某URL对应的图片到缓存使用内部的ImageCache将图片进行缓存到磁盘 123456- (void)saveImageToCache:(nullable UIImage *)image forURL:(nullable NSURL *)url { if (image &amp;&amp; url) { NSString *key = [self cacheKeyForURL:url]; [self.imageCache storeImage:image forKey:key toDisk:YES completion:nil]; }} 异步检测内存中/磁盘中是否有图片 检测内存中是否有缓存1234567891011121314151617181920212223- (void)cachedImageExistsForURL:(nullable NSURL *)url completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock { NSString *key = [self cacheKeyForURL:url]; BOOL isInMemoryCache = ([self.imageCache imageFromMemoryCacheForKey:key] != nil); if (isInMemoryCache) { // making sure we call the completion block on the main queue dispatch_async(dispatch_get_main_queue(), ^{ if (completionBlock) { completionBlock(YES); } }); return; } [self.imageCache diskImageExistsWithKey:key completion:^(BOOL isInDiskCache) { // the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch if (completionBlock) { completionBlock(isInDiskCache); } }];} 检测磁盘中是否有图片1234567891011- (void)diskImageExistsForURL:(nullable NSURL *)url completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock { NSString *key = [self cacheKeyForURL:url]; [self.imageCache diskImageExistsWithKey:key completion:^(BOOL isInDiskCache) { // the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch if (completionBlock) { completionBlock(isInDiskCache); } }];} 获取某个URL对应的缓存key辅助方法，获取url对应的图片key,允许用户对URL进行筛选1234567891011- (nullable NSString *)cacheKeyForURL:(nullable NSURL *)url { if (!url) { return @&quot;&quot;; } if (self.cacheKeyFilter) { return self.cacheKeyFilter(url); } else { return url.absoluteString; }} 小结SDWebImageManager 相对还是比较简单，因为内部已经有下载和缓存类的实现了，下载图片时，先判断缓存的情况，如果缓存中有，进行缓存获取的回调，如果没有或者强制要求刷新的话，就会执行下载操作。期间把操作要进行保存到运行数组中，这样的话，如果有取消，也可以拿到对象进行取消操作。 下一小节，研究下，三方库如果进行进一步的封装，然后可以供用户方便的使用？而不用关注内部的实现细节！","link":"/2017/01/16/SDWebImage%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"},{"title":"SDWebImage学习笔记（二）","text":"缓存这一小节主要研究下SDWebImage的cache功能是如何实现的，首先找到在SDWebImage中充当缓存功能的类，这一步很简单，直接定位到SDImageCache类。也就是说，接下来主要就研究这个类了。 SDImageCacheConfig 缓存配置SDWebImage提供了一个专门的类SDImageCacheConfig，来进行Cache的一些配置工作，主要配置的信息包括以下几点 是否允许解压原图 是否支持iCloud，默认不支持 是否允许将图片缓存到内存，默认支持 最大缓存周期（默认是一周） 最大缓存大小（默认不设置） SDImageCache 缓存类SDImageCache是一个单例，作为执行图片缓存的工具类，整个App只需要有一个全局的实例就可以了，这没毛病。 SDImageCache文件系统在开始缓存操作之前，除了配置项需要配置外，我个人感觉还有一个地方需要提前准备好的就是缓存的文件系统。 默认的文件存储路径SDImageCache的默认文件存储路径是由单例去控制的，在单例初始化的时候，传入了默认的文件夹名称default，这样的话，默认的文件路径就是../cache/default/com.hackemist.SDWebImageCache. default/ 文件夹。 用户自己定义的文件路径SDImageCache还支持用户自己定义的命名空间，所需要做的就是在创建的时候传入namespace，即可，这样的话，假如用户传入了YoukuImages，那么 缓存的文件路径就是../cache/YoukuImages/com.hackemist.SDWebImageCache.YoukuImages/ 文件夹了。 辅助的文件路径方法这个并不是很复杂，之所以要提一嘴，主要是比较赞赏SDWebImage的函数命名，代码如下 1234- (nullable NSString *)makeDiskCachePath:(nonnull NSString*)fullNamespace { NSArray&lt;NSString *&gt; *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); return [paths[0] stringByAppendingPathComponent:fullNamespace];} 图片存储路径图片的存储路径采用了对URL进行MD5加密的方式，进行处理，通过这种方式防止文件被盗链给服务端增加流量损耗。MD5也是很常见的加密方式，下面附上代码，方便自己以后查看。注意，这里稍微和别的MD5加密的不同的就是，会把文件扩展名带上，比如.png,.jpg之类的。这个方法，其实是提供了一个URL到文件名的映射 12345678910111213- (nullable NSString *)cachedFileNameForKey:(nullable NSString *)key { const char *str = key.UTF8String; if (str == NULL) { str = &quot;&quot;; } unsigned char r[CC_MD5_DIGEST_LENGTH]; CC_MD5(str, (CC_LONG)strlen(str), r); NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;, r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15], [key.pathExtension isEqualToString:@&quot;&quot;] ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, key.pathExtension]]; return filename;} 另外提供俩个函数，方便获取文件默认存储路径下指定key图片的方法 12345// 获取指定路径下名称为key的图片路径- (nullable NSString *)cachePathForKey:(nullable NSString *)key inPath:(nonnull NSString *)path { NSString *filename = [self cachedFileNameForKey:key]; return [path stringByAppendingPathComponent:filename];} 1234// 获取默认路径下key的图片路径，一般情况都是直接使用该方法就获取到图片的路径了- (nullable NSString *)defaultCachePathForKey:(nullable NSString *)key { return [self cachePathForKey:key inPath:self.diskCachePath];} SDImageCache的初始化自从Xcode8之后，编译器好像做了一些优化，init方法需要去调用其他的NS_DESIGNATED_INITIALIZER标记的初始化方法，SDImageCache显然也是响应了这样的号召，所以提供了俩个自定义的初始化方法initWithNamespace:和initWithNamespace:diskCacheDirectory:，分别支持按照命名空间及存储路径的自定义初始化。但是单例的初始化会调用默认的初始化方法，使用单例的时候，会在App的Cache文件夹下面创建你一个default的文件夹，并在该Default文件夹下创建com.hackmisk.SDWebImageCache.default的一个文件夹，使用该文件夹来存储图片。下面是初始化的一些代码，并不是很复杂。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273+ (nonnull instancetype)sharedImageCache { static dispatch_once_t once; static id instance; dispatch_once(&amp;once, ^{ instance = [self new]; }); return instance;}- (instancetype)init { return [self initWithNamespace:@&quot;default&quot;];}- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns { NSString *path = [self makeDiskCachePath:ns]; return [self initWithNamespace:ns diskCacheDirectory:path];}- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns diskCacheDirectory:(nonnull NSString *)directory { if ((self = [super init])) { NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns]; // Create IO serial queue _ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL); //目前这里使用的都是默认配置 _config = [[SDImageCacheConfig alloc] init]; // Init the memory cache // 创建内存缓存 _memCache = [[AutoPurgeCache alloc] init]; _memCache.name = fullNamespace; // Init the disk cache if (directory != nil) { // 单例形式创建的时候，这里肯定是能执行到的，之后就会创建com.hackmisk.SDWebImageCache.default的缓存路径 _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace]; } else { NSString *path = [self makeDiskCachePath:ns]; _diskCachePath = path; } // 此处需要稍微注意一下，因为io队列主要是对图片进行增删读写等操作，需要保证fileManager创建在io队列上。 dispatch_sync(_ioQueue, ^{ _fileManager = [NSFileManager new]; });#if SD_UIKIT // Subscribe to app events [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(clearMemory) name:UIApplicationDidReceiveMemoryWarningNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deleteOldFiles) name:UIApplicationWillTerminateNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(backgroundDeleteOldFiles) name:UIApplicationDidEnterBackgroundNotification object:nil];#endif } return self;}//辅助方法，便捷式创建缓存路径- (nullable NSString *)makeDiskCachePath:(nonnull NSString*)fullNamespace { NSArray&lt;NSString *&gt; *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); return [paths[0] stringByAppendingPathComponent:fullNamespace];} SDImageCache的缓存操作存这里同样提供了三个方法方便使用者根据不同的需求进行图片存储功能的选择。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 使用默认的存储路径，并默认存储到磁盘- (void)storeImage:(nullable UIImage *)image forKey:(nullable NSString *)key completion:(nullable SDWebImageNoParamsBlock)completionBlock { [self storeImage:image imageData:nil forKey:key toDisk:YES completion:completionBlock];}// 该方法可供用户选择是否能够保存到磁盘- (void)storeImage:(nullable UIImage *)image forKey:(nullable NSString *)key toDisk:(BOOL)toDisk completion:(nullable SDWebImageNoParamsBlock)completionBlock { [self storeImage:image imageData:nil forKey:key toDisk:toDisk completion:completionBlock];}// 此处提供了图片的NSdata数据，可供用户直接存储。- (void)storeImage:(nullable UIImage *)image imageData:(nullable NSData *)imageData forKey:(nullable NSString *)key toDisk:(BOOL)toDisk completion:(nullable SDWebImageNoParamsBlock)completionBlock { // 做下异常校验，如果图片或者key不存在，直接返回 if (!image || !key) { if (completionBlock) { completionBlock(); } return; } // 检验下配置类是否允许将图片保存到内存，如果允许就进行保存处理 if (self.config.shouldCacheImagesInMemory) { NSUInteger cost = SDCacheCostForImage(image); [self.memCache setObject:image forKey:key cost:cost]; } // 是否需要保存到磁盘 if (toDisk) { // 保存需要在IO队列中进行，先检验图片NSdata是否存在，如果只有UIImage对象，需要先转换成Data类型 dispatch_async(self.ioQueue, ^{ NSData *data = imageData; if (!data &amp;&amp; image) { SDImageFormat imageFormatFromData = [NSData sd_imageFormatForImageData:data]; data = [image sd_imageDataAsFormat:imageFormatFromData]; } [self storeImageDataToDisk:data forKey:key]; if (completionBlock) { dispatch_async(dispatch_get_main_queue(), ^{ completionBlock(); }); } }); } else { if (completionBlock) { completionBlock(); } }}// 保存数据到磁盘，注意保存操作要在IO队列上进行。并根据是否要保存到iCloud对URL进行设置- (void)storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key { if (!imageData || !key) { return; } // 检查下是否是在IO队列上，因为读写操作要在单独的异步队列进行 [self checkIfQueueIsIOQueue]; // 检查是否在当前的目录下存在文件夹，如不存在，先创建之 if (![_fileManager fileExistsAtPath:_diskCachePath]) { [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL]; } // 获取缓存图片地址文件夹路径 NSString *cachePathForKey = [self defaultCachePathForKey:key]; // 转变为文件URL NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey]; // 保存操作 [_fileManager createFileAtPath:cachePathForKey contents:imageData attributes:nil]; // 阻止图片保存到iCloud if (self.config.shouldDisableiCloud) { [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil]; }} 取&amp;查SDWebImageCache提供了查询内存图片、磁盘图片的功能，还提供了查询默认路径和自定义路径下某个key对应的图片。 检测图片是否在磁盘中有缓存 1234567891011121314151617 - (void)diskImageExistsWithKey:(nullable NSString *)key completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock { dispatch_async(_ioQueue, ^{ BOOL exists = [_fileManager fileExistsAtPath:[self defaultCachePathForKey:key]]; // fallback because of https://github.com/rs/SDWebImage/pull/976 that added the extension to the disk file name // checking the key with and without the extension if (!exists) { exists = [_fileManager fileExistsAtPath:[self defaultCachePathForKey:key].stringByDeletingPathExtension]; } if (completionBlock) { dispatch_async(dispatch_get_main_queue(), ^{ completionBlock(exists); }); } });} 获取内存/磁盘上缓存的图片 123456789101112131415161718192021 - (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key { return [self.memCache objectForKey:key];} - (nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key { UIImage *diskImage = [self diskImageForKey:key]; if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) { NSUInteger cost = SDCacheCostForImage(diskImage); [self.memCache setObject:diskImage forKey:key cost:cost]; } - (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)key { // First check the in-memory cache... UIImage *image = [self imageFromMemoryCacheForKey:key]; if (image) { return image; } // Second check the disk cache... image = [self imageFromDiskCacheForKey:key]; return diskImage;} 辅助方法，获取所有路径下是否有该key缓存的图片 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 - (nullable NSData *)diskImageDataBySearchingAllPathsForKey:(nullable NSString *)key { NSString *defaultPath = [self defaultCachePathForKey:key]; NSData *data = [NSData dataWithContentsOfFile:defaultPath]; if (data) { return data; } // fallback because of https://github.com/rs/SDWebImage/pull/976 that added the extension to the disk file name // checking the key with and without the extension data = [NSData dataWithContentsOfFile:defaultPath.stringByDeletingPathExtension]; if (data) { return data; } NSArray&lt;NSString *&gt; *customPaths = [self.customPaths copy]; for (NSString *path in customPaths) { NSString *filePath = [self cachePathForKey:key inPath:path]; NSData *imageData = [NSData dataWithContentsOfFile:filePath]; if (imageData) { return imageData; } // fallback because of https://github.com/rs/SDWebImage/pull/976 that added the extension to the disk file name // checking the key with and without the extension imageData = [NSData dataWithContentsOfFile:filePath.stringByDeletingPathExtension]; if (imageData) { return imageData; } } return nil;} - (nullable UIImage *)diskImageForKey:(nullable NSString *)key { NSData *data = [self diskImageDataBySearchingAllPathsForKey:key]; if (data) { UIImage *image = [UIImage sd_imageWithData:data]; image = [self scaledImageForKey:key image:image]; if (self.config.shouldDecompressImages) { image = [UIImage decodedImageWithImage:image]; } return image; } else { return nil; }} 提供供外部调用的，且返回一个Operation对象的查询某Key的图片 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 - (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key done:(nullable SDCacheQueryCompletedBlock)doneBlock { if (!key) { if (doneBlock) { doneBlock(nil, nil, SDImageCacheTypeNone); } return nil; } // First check the in-memory cache... UIImage *image = [self imageFromMemoryCacheForKey:key]; if (image) { NSData *diskData = nil; if ([image isGIF]) { diskData = [self diskImageDataBySearchingAllPathsForKey:key]; } if (doneBlock) { doneBlock(image, diskData, SDImageCacheTypeMemory); } return nil; } NSOperation *operation = [NSOperation new]; dispatch_async(self.ioQueue, ^{ if (operation.isCancelled) { // do not call the completion if cancelled return; } @autoreleasepool { NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; UIImage *diskImage = [self diskImageForKey:key]; if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) { NSUInteger cost = SDCacheCostForImage(diskImage); [self.memCache setObject:diskImage forKey:key cost:cost]; } if (doneBlock) { dispatch_async(dispatch_get_main_queue(), ^{ doneBlock(diskImage, diskData, SDImageCacheTypeDisk); }); } } }); return operation;} 删同样，删除也包括删除内存中的图片和删除磁盘中的图片，俩种，比较简单，下面是源码，可以参考下 12345678910111213141516171819 - (void)clearMemory { [self.memCache removeAllObjects]; } - (void)clearDiskOnCompletion:(nullable SDWebImageNoParamsBlock)completion { dispatch_async(self.ioQueue, ^{ [_fileManager removeItemAtPath:self.diskCachePath error:nil]; [_fileManager createDirectoryAtPath:self.diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL]; if (completion) { dispatch_async(dispatch_get_main_queue(), ^{ completion(); }); } });} 删除这块，唯一需要特别注意的就是删除过期的文件，以及对文件大小的存储上限做校验，如果超过最大上限，将最老的文件删除掉 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 - (void)deleteOldFiles { [self deleteOldFilesWithCompletionBlock:nil];}- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock { dispatch_async(self.ioQueue, ^{ NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES]; NSArray&lt;NSString *&gt; *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey]; // This enumerator prefetches useful properties for our cache files. NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL includingPropertiesForKeys:resourceKeys options:NSDirectoryEnumerationSkipsHiddenFiles errorHandler:NULL]; NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge]; NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = [NSMutableDictionary dictionary]; NSUInteger currentCacheSize = 0; // Enumerate all of the files in the cache directory. This loop has two purposes: // // 1. Removing files that are older than the expiration date. // 2. Storing file attributes for the size-based cleanup pass. NSMutableArray&lt;NSURL *&gt; *urlsToDelete = [[NSMutableArray alloc] init]; for (NSURL *fileURL in fileEnumerator) { NSError *error; NSDictionary&lt;NSString *, id&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error]; // Skip directories and errors. if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) { continue; } // Remove files that are older than the expiration date; NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey]; if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) { [urlsToDelete addObject:fileURL]; continue; } // Store a reference to this file and account for its total size. NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey]; currentCacheSize += totalAllocatedSize.unsignedIntegerValue; cacheFiles[fileURL] = resourceValues; } for (NSURL *fileURL in urlsToDelete) { [_fileManager removeItemAtURL:fileURL error:nil]; } // If our remaining disk cache exceeds a configured maximum size, perform a second // size-based cleanup pass. We delete the oldest files first. if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) { // Target half of our maximum cache size for this cleanup pass. const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2; // Sort the remaining cache files by their last modification time (oldest first). NSArray&lt;NSURL *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent usingComparator:^NSComparisonResult(id obj1, id obj2) { return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]]; }]; // Delete files until we fall below our desired cache size. for (NSURL *fileURL in sortedFiles) { if ([_fileManager removeItemAtURL:fileURL error:nil]) { NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles[fileURL]; NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey]; currentCacheSize -= totalAllocatedSize.unsignedIntegerValue; if (currentCacheSize &lt; desiredCacheSize) { break; } } } } if (completionBlock) { dispatch_async(dispatch_get_main_queue(), ^{ completionBlock(); }); } });} 对后台删除的支持，当APP在删除的时候，切换到后台，需要支持后台删除文件 12345678910111213141516171819 - (void)backgroundDeleteOldFiles { Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;); if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) { return; } UIApplication *application = [UIApplication performSelector:@selector(sharedApplication)]; __block UIBackgroundTaskIdentifier bgTask = [application beginBackgroundTaskWithExpirationHandler:^{ // Clean up any unfinished task business by marking where you // stopped or ending the task outright. [application endBackgroundTask:bgTask]; bgTask = UIBackgroundTaskInvalid; }]; // Start the long-running task and return immediately. [self deleteOldFilesWithCompletionBlock:^{ [application endBackgroundTask:bgTask]; bgTask = UIBackgroundTaskInvalid; }];} 缓存的信息除了支持存、查、取、删，之外，SDWebImageCache还提供了方便查看缓存的文件数、缓存的总大小、以及实时计算文件大小的block异步回调，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 - (NSUInteger)getSize { __block NSUInteger size = 0; dispatch_sync(self.ioQueue, ^{ NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtPath:self.diskCachePath]; for (NSString *fileName in fileEnumerator) { NSString *filePath = [self.diskCachePath stringByAppendingPathComponent:fileName]; NSDictionary&lt;NSString *, id&gt; *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil]; size += [attrs fileSize]; } }); return size;}- (NSUInteger)getDiskCount { __block NSUInteger count = 0; dispatch_sync(self.ioQueue, ^{ NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtPath:self.diskCachePath]; count = fileEnumerator.allObjects.count; }); return count;}- (void)calculateSizeWithCompletionBlock:(nullable SDWebImageCalculateSizeBlock)completionBlock { NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES]; dispatch_async(self.ioQueue, ^{ NSUInteger fileCount = 0; NSUInteger totalSize = 0; NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL includingPropertiesForKeys:@[NSFileSize] options:NSDirectoryEnumerationSkipsHiddenFiles errorHandler:NULL]; for (NSURL *fileURL in fileEnumerator) { NSNumber *fileSize; [fileURL getResourceValue:&amp;fileSize forKey:NSURLFileSizeKey error:NULL]; totalSize += fileSize.unsignedIntegerValue; fileCount += 1; } if (completionBlock) { dispatch_async(dispatch_get_main_queue(), ^{ completionBlock(fileCount, totalSize); }); } });} 小结通过这一小节对源码的分析，我们大概知道了SDWebImage的缓存工作原理。也对文件操作有了一个更深刻的理解，下一小节将研究下SDWebImageManager是如果对下载和缓存进行综合管理的。","link":"/2017/01/06/SDWebImage%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"Tree命令及简单使用","text":"我用的是阿里云服务器，CentOS7，默认没有tree这个命令，需要安装，用下面的命令就可以安装： 1sudo yum install tree 怎么样使用tree这个命令其实有个非常简单的办法，就是直接查看关于tree的帮助，输入下面的命令，可以查看关于tree命令的帮助信息 1tree --help 最简单的使用办法是直接输入tree命令，就会自动给我们以树形的形式列出当前目录的文件和文件夹，不加任何参数，它会自动列表当前目录下面所有深度级别的文件和目录。 几个比较常规的用法 显示目录结构1tree 包含隐藏文件 1tree -a 控制深度（假设为2） 1tree -L 2 更多的选项 选项 说明 -a 显示所有文件，包含隐藏文件。 -d 只显示目录。 -l 跟踪符号链接，如果链接的是一个目录，则当成目录处理。 -f 显示完整路径。 -x 只显示本文件系统。 -L level 控制显示的目录深度。 -R 在下级目录中，再次执行 tree 命令并且加上 ‘-o 00Tree.html’选项，配合-L,-H使用。 -P pattern 只显示匹配了 pattern 的文件（不是目录），支持简单的正则表达式。 -I pattern 与-P相反，只显示没有匹配 pattern的文件。 –ignore-case 当使用了-P或-I选项时，忽略大小写。 –matchdirs 当使用了-P选项时，文件名包含完整路径。 –prune 不显示空目录，如果经过-P或-I后没有目录下没有需要显示的，也当作空目录。 –noreport 不显示最后的统计信息。 –charset charset 指定字符集。 –filelimit # 过滤掉文件个数超过 # 的目录。 –timefmt fmt 按照指定的格式打印文件的修改时间。 -o filename 将结果输出到文件。 -q 用问号代替不可打印的字符。 -N 用八进制代替不可打印的字符。 -Q 用引号将文件名括起来。 -p 显示文件的类型和权限。 -u 显示文件所属的用户名或者UID。 -g 显示文件所属的组或者GID。 -s 显示文件的大小，单位：字节 -h 显示文件的大小，使用更人性化的显示。 –si 显示文件的大小，类似 -h 但是使用国际公制单位(1k=1000)。 –du 对于目录，显示其下所有文件的累计大小。 -D 显示文件的最后修改时间。 -F 类似 ls -F，对不同的文件类，在末尾加上不同的字符。 –inodes 显示文件的索引节点。 –device 显示文件所属的设备号。 -v 显示的文件列表按照version排序。 -t 显示的文件列表按照最后修改时间排序。 -c 显示的文件列表按照最后的状态改变时间排序。 -U 不进行排序处理。 -r 反向输出列表。 –dirsfirst 优先显示目录（同一级别） –sort[=name] 指定排序方式，name(default), ctime, mtime, size, version. -i 输出中不要进行缩进。 -A 使用ASCII的横线字符表示缩进。 -S 使用CP437的横线字符表示缩进。 -n 关闭颜色显示。 -C 打开颜色显示。 -X 使能XML格式输出。 -J 使能JSON格式输出。 -H baseHREF 使能HTML格式输出，并包含基本http链接地址。 -T title 在HTML格式输出中，设置标题和H1标签头 –nolinks 在HTML格式输出中，不输出超链接。","link":"/2022/08/09/Tree%E5%91%BD%E4%BB%A4%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"title":"hexo本地图片放置问题","text":"(转) 原 文 地 址 起因在 hexo 中使用本地图片是件非常让人纠结的事情，在 markdown 里的图片地址似乎永远无法和最后生成的网页保持一致。 这些问题使得我一度不愿意使用本地图片而选择用图床，但被移动运营商无耻的横条广告逼得打算上 https，图床只支持 http 就成了问题。 hexo 下插入图片现在大概有几个方案 放在根目录 早期大部分的方案是把图片放在 source/img 下，然后在 markdown 里写 ![img](/source/img/img.png) 。显然这样在本地的编辑器里完全不能正确识别图片的位置。 asset-image 在 hexo 2.x 时出现的插件，后来被吸纳进 hexo 3 core ，用法的介绍见 资源文件夹 | Hexo 。比较尴尬的是，这种方法直接放弃了 markdown 原来的语法，使用类似 ``的语法，。markdown 本来有插入图片的语法不好好支持，专门用一个新的语法来插入本地图片，让我这种强迫症不太能接受。 解决方案CodeFalling/hexo-asset-image 首先确认 _config.yml 中有 post_asset_folder:true 。 在 hexo 目录，执行 12npm install https://github.com/CodeFalling/hexo-asset-image --save 假设在 12345MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](MacGesture2-Publish/logo.jpg) 就可以插入图片。 生成的结构为 12345public/2015/10/18/MacGesture2-Publish├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg 同时，生成的 html 是 12&lt;img src=&quot;/2015/10/18/MacGesture2-Publish/logo.jpg&quot; alt=&quot;logo&quot;&gt; 而不是愚蠢的 12&lt;img src=&quot;MacGesture2-Publish/logo.jpg&quot; alt=&quot;logo&quot;&gt; 值得一提的是，这个插件对于 CodeFalling/hexo-renderer-org 同样有效","link":"/2017/05/06/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E6%94%BE%E7%BD%AE%E9%97%AE%E9%A2%98/"},{"title":"iOS开发中遇到的同步机制","text":"​ 今天主要是来讨论下，线程同步机制的问题。说到线程同步，一般人可能会想到“NSLock”、“@synchronized”、“GCD信号量”等等，好吧，其实这是我想到的，然而我要说的是，如果在面试中只答到这么几个可是远远不够的。所以我查找了下资料，这才发现原来ios中线程同步的方法可足足有将近10种，且听我娓娓道来。 各个锁进行1000000此的加锁解锁的空操作时间如下 123456789OSSpinLock: 46.15 msdispatch_semaphore: 56.50 mspthread_mutex: 178.28 msNSCondition: 193.38 msNSLock: 175.02 mspthread_mutex(recursive): 172.56 msNSRecursiveLock: 157.44 msNSConditionLock: 490.04 ms@synchronized: 371.17 ms NSLock​ 提到NSLock，首先要提另外一个名词叫NSLocking，这是一个协议，主要就定义了俩个方法，一个叫 lock,一个叫unLock。NSLock其实就是确认了NSLocking协议的一个NSObject对象，那么NSLock如何使用呢？其实很简单，就是在你认为可能会发生多线程访问的地方进行lock 操作，在执行完相应代码之后，执行unlock操作。举个简单例子 1234567891011121314151617181920212223242526272829303132-(void)testLock{// 先简单描述下使用场景，现在有一个线程1，有一个线程2，都要访问字符串name，且线程1访问字符串要耗时3秒，线程2此时需要等待。 __block NSString *name = @&quot;成焱&quot;; NSOperationQueue *queue = [[NSOperationQueue alloc]init]; queue.maxConcurrentOperationCount = 3; NSLock *lock = [NSLock new]; [queue addOperationWithBlock:^{ NSLog(@&quot;1 将要上锁&quot;); [lock lock]; NSLog(@&quot;1 已上锁，访问资源&quot;); name = @&quot;哇哈哈&quot;; sleep(3); NSLog(@&quot;1 将要解锁&quot;); [lock unlock]; NSLog(@&quot;1 已解锁&quot;); }]; [queue addOperationWithBlock:^{ sleep(1);//保证此线程后面的方法后调用 NSLog(@&quot;2 将要上锁&quot;); [lock lock]; NSLog(@&quot;2 已上锁，访问资源&quot;); name = @&quot;康师傅&quot;; sleep(2); NSLog(@&quot;2 将要解锁&quot;); [lock unlock]; NSLog(@&quot;2 已解锁&quot;); }];} ​ 打印结果如下 123456782017-04-24 23:06:59.831694 test[1300:102434] 1 将要上锁2017-04-24 23:06:59.831718 test[1300:102434] 1 已上锁，访问资源2017-04-24 23:07:00.835992 test[1300:102435] 2 将要上锁2017-04-24 23:07:02.836242 test[1300:102434] 1 将要解锁2017-04-24 23:07:02.836385 test[1300:102434] 1 已解锁2017-04-24 23:07:02.836443 test[1300:102435] 2 已上锁，访问资源2017-04-24 23:07:04.841407 test[1300:102435] 2 将要解锁2017-04-24 23:07:04.841528 test[1300:102435] 2 已解锁 查看控制台的打印输出很明显的看到了，在线程一访问name时，加锁之后，线程2一直在等待，直到线程1释放锁之后，线程2才会去访问name。 @synchronize​ 想必但凡是开发过一段时间ios程序的同学，一定会对这个关键字不陌生。这个关键字的字面意思就是“同步”。那么它是如何实现同步的呢？ ​ 该特性允许传入一个NSObject类型的对象，并执行一个block，形如 123@syncronized(obj){ // do work} ​ 网上查询资料获得，这个特性其实是对objc_sync_enter()于objc_sync_exit()的封装，其实际上等价于 12345@try{ objc_sync_enter(obj); }@finally{ objc_sync_exit(obj); } ​ 函数objc_sync_enter()内部实际进行的操作，是对传入的对象，分配递归锁，并存在哈希表中，感兴趣的同学可以参考这篇blog,在这里我就不展开讨论了。不过下面还是举个简单例子来说明下如何使用这个特性，这里有个地方需要注意就是，**当传入的对象为nil时，将会从代码中移走线程安全** 1234567891011121314151617181920212223- (void)testSynchronized{ __block NSString *source = @&quot;资源&quot;; dispatch_queue_t global = dispatch_get_global_queue(0, 0); dispatch_async(global, ^{ @synchronized (source) { NSLog(@&quot;1 将要执行&quot;); sleep(3); NSLog(@&quot;1 执行完毕&quot;); } }); dispatch_async(global, ^{ sleep(1);//只是为了让这个线程后调用 @synchronized (source) { NSLog(@&quot;2 将要执行&quot;); sleep(1); NSLog(@&quot;2 执行完毕&quot;); } }); } ​ 打印结果如下 12342017-04-24 23:43:01.933835 test[1589:154385] 1 将要执行2017-04-24 23:43:04.938447 test[1589:154385] 1 执行完毕2017-04-24 23:43:04.938782 test[1589:154386] 2 将要执行2017-04-24 23:43:05.942177 test[1589:154386] 2 执行完毕 信号量​ GCD的信号量机制，通过消耗信号的方式，控制线程同步 12345678910111213141516171819202122- (void)testSemaphore{ dispatch_queue_t global = dispatch_get_global_queue(0, 0); dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); dispatch_async(global, ^{ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;1 将要执行&quot;); sleep(3); NSLog(@&quot;1 执行完毕&quot;); dispatch_semaphore_signal(semaphore); }); dispatch_async(global, ^{ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;2 将要执行&quot;); sleep(3); NSLog(@&quot;2 执行完毕&quot;); dispatch_semaphore_signal(semaphore); });} ***打印结果如下*** 12342017-04-26 22:32:17.563019 test[914:142382] 1 将要执行2017-04-26 22:32:20.568142 test[914:142382] 1 执行完毕2017-04-26 22:32:20.568336 test[914:142383] 2 将要执行2017-04-26 22:32:23.573598 test[914:142383] 2 执行完毕 NSConditionLock​ 条件锁，当满足某种条件时，才会尝试获取锁，利用该特性，可以人为干预线程执行的依赖顺序，参见如下代码 1234567891011121314151617181920212223242526272829303132333435363738- (void)testConditionLock{ int condition = 1; // 当满足条件时，如果锁空闲，可以获取到锁 NSConditionLock *conditionLock = [[NSConditionLock alloc]initWithCondition:condition]; dispatch_queue_t global = dispatch_get_global_queue(0, 0); dispatch_async(global, ^{ BOOL islocked = [conditionLock tryLockWhenCondition:1]; NSLog(@&quot;线程1 要执行&quot;); sleep(2); NSLog(@&quot;线程1 执行完毕&quot;); if (islocked) { [conditionLock unlockWithCondition:3]; } }); dispatch_async(global, ^{ BOOL isLocked = [conditionLock lockWhenCondition:2 beforeDate:[NSDate dateWithTimeIntervalSinceNow:10]]; NSLog(@&quot;线程2 要执行&quot;); sleep(2); NSLog(@&quot;线程2 执行完毕&quot;); if (isLocked) { [conditionLock unlockWithCondition:1]; } }); dispatch_async(global, ^{ BOOL isLocked = [conditionLock tryLockWhenCondition:3]; NSLog(@&quot;线程3 要执行&quot;); sleep(3); NSLog(@&quot;线程3 执行完毕&quot;); if (isLocked) { NSLog(@&quot;加锁了&quot;); [conditionLock unlockWithCondition:10]; } }); } ​ 打印结果如下 1234562017-04-26 23:11:56.343532 test[1092:199052] 线程1 要执行2017-04-26 23:11:56.343546 test[1092:199054] 线程3 要执行2017-04-26 23:11:58.348745 test[1092:199052] 线程1 执行完毕2017-04-26 23:11:59.348618 test[1092:199054] 线程3 执行完毕2017-04-26 23:12:06.348449 test[1092:199053] 线程2 要执行2017-04-26 23:12:08.353647 test[1092:199053] 线程2 执行完毕 dispatch_barrier_async()与dispatch_barrier_sync()​ GCD提供了线程顺序控制的一个函数，假设有5个任务要执行，需要前俩个并发执行，执行完成之后执行第三个任务，等第三个执行完成才可以执行第四个和第五个任务，这个时候就可以考虑使用dispath_barrier_async()函数，具体dispatch_barrier_asyn与dispatch_barrier_sync有什么区别的话，稍后再说，请看下面这个例子 12345678910111213141516171819202122232425262728- (void)testBarrierAsyncAndSync{ /// 创建一个并发执行的队列 dispatch_queue_t global = dispatch_queue_create(&quot;com.demo.chengyan&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(global, ^{ NSLog(@&quot;任务1&quot;); }); dispatch_async(global, ^{ NSLog(@&quot;任务2&quot;); }); dispatch_barrier_async(global, ^{ sleep(3); NSLog(@&quot;任务3&quot;); }); NSLog(@&quot;---------------&quot;); dispatch_async(global, ^{ NSLog(@&quot;任务4&quot;); }); dispatch_async(global, ^{ NSLog(@&quot;任务5&quot;); });} ​ 打印结果如下 1234562017-04-26 23:43:08.653034 test[1214:243421] ---------------2017-04-26 23:43:08.653138 test[1214:243447] 任务12017-04-26 23:43:08.653151 test[1214:243448] 任务22017-04-26 23:43:11.654589 test[1214:243447] 任务32017-04-26 23:43:11.654715 test[1214:243447] 任务42017-04-26 23:43:11.654728 test[1214:243448] 任务5 ​ 可以看到由于是通过async的方式添加到队列中的，所以没有阻塞主线程，—————–被最先执行了。同时注意到在任务3中，沉睡了3秒，而任务4和5都在等任务3执行完之后，才开始执行的。 ​ 那么接下来再看下sync的方式执行barrier会怎么样？ 12345678910111213141516171819202122232425262728- (void)testBarrierAsyncAndSync{ /// 创建一个并发执行的队列 dispatch_queue_t global = dispatch_queue_create(&quot;com.demo.chengyan&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(global, ^{ NSLog(@&quot;任务1&quot;); }); dispatch_async(global, ^{ NSLog(@&quot;任务2&quot;); }); dispatch_barrier_sync(global, ^{ sleep(3); NSLog(@&quot;任务3&quot;); }); NSLog(@&quot;---------------&quot;); dispatch_async(global, ^{ NSLog(@&quot;任务4&quot;); }); dispatch_async(global, ^{ NSLog(@&quot;任务5&quot;); });} ​ 打印结果如下 1234562017-04-26 23:53:57.275541 test[1249:258152] 任务12017-04-26 23:53:57.275542 test[1249:258154] 任务22017-04-26 23:54:00.280724 test[1249:258129] 任务32017-04-26 23:54:00.280832 test[1249:258129] ---------------2017-04-26 23:54:00.280944 test[1249:258154] 任务42017-04-26 23:54:00.281000 test[1249:258152] 任务5 ​ 可以看到由于sync的方式，阻塞了主线程的操作，导致主线程后面的打印必须要等任务3完成之后才会执行。所以尽量不要用这种方式在主线程调用。防止卡到ui GCD的串行队列实际上也是可以起到锁的作用（略）os_unfair_lock（系统非公平锁）​ 在IOS10，MacOS10.12之后，苹果新提供的锁，用来替代OSSPinLock,根据官方文档说明，该锁解决了OSSPinLock的优先级反转问题，主要是通过该锁上携带的值以及它持有线程的所有权信息，系统可以以此做出相应的策略，来解决优先级反转的问题。就像它的名字一样，这是个非公平锁。 ​ 使用此锁，需要注意的是 unlock和lock操作必须得在同一个线程中，如果在不同的线程中解锁，将会导致线程直接crash。 该锁决不能通过shared或者mutiplay_mapped memory的方式，在多线程或者多进程中访问。因为该锁的实现，依赖于该锁的值和所在的进程。 该锁主要是为了替代废弃的OSSPinLock，但是它在争夺资源的时候，不是靠自旋，而是在内核上等待唤醒。 Mac系统开发要在10.12之后只用，iOS需要在iOS10以后才能使用 ​ 最后要说明的是，此锁就像它的名字一样，是非公平的，具体啥意思呢？举个例子，解开锁的消费者，存在一种可能立即又重新获得了锁，导致那些在休眠中等待的不能被唤醒。这可能是处于性能的考虑，但是确实有一种可能导致等待者处于饥饿状态。 ​ 下面的代码简要演示下如何使用该锁 12345678910111213141516171819202122232425#import &lt;os/lock.h&gt;- (void)testUnfairlock{ os_unfair_lock_t unfairlock = &amp;OS_UNFAIR_LOCK_INIT; dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_async(queue, ^{ sleep(1); os_unfair_lock_lock(unfairlock); NSLog(@&quot;线程1 将要执行&quot;); sleep(3); NSLog(@&quot;线程1 执行结束&quot;); os_unfair_lock_unlock(unfairlock); }); dispatch_async(dispatch_get_main_queue(), ^{ os_unfair_lock_lock(unfairlock); NSLog(@&quot;线程2 将要执行&quot;); sleep(2); NSLog(@&quot;线程2 执行结束&quot;); os_unfair_lock_unlock(unfairlock); }); } ​ 打印结果如下 12342017-04-28 00:14:11.692782 test[892:121163] 线程2 将要执行2017-04-28 00:14:13.698007 test[892:121163] 线程2 执行结束2017-04-28 00:14:13.698230 test[892:121192] 线程1 将要执行2017-04-28 00:14:16.700588 test[892:121192] 线程1 执行结束 pthread_mutex_t（互斥锁）​ 互斥锁和自旋锁的区别，主要就在于，当获取锁失败之后，自旋锁会一直轮询，而互斥锁会轮询大概一秒之后，进入休眠，等待唤醒，此外互斥锁，是有队列概念的，有一个等待队列，依次唤醒等待者。 ​ 互斥锁和NSLock的区别则在于互斥锁trylock返回正确时返回0，错误时返回错误值，而NSLock则只会返回NO和YES。 ​ 此外互斥锁也是性能比较高的锁。使用方式的话，如下 123456789101112131415161718192021222324252627- (void)testPthreadMutex{ static pthread_mutex_t plock; pthread_mutex_init(&amp;plock, NULL); dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_async(queue, ^{ sleep(1); pthread_mutex_lock(&amp;plock); NSLog(@&quot;线程1 将要执行&quot;); sleep(3); NSLog(@&quot;线程1 执行结束&quot;); pthread_mutex_unlock(&amp;plock); }); dispatch_async(dispatch_get_main_queue(), ^{ int code = pthread_mutex_lock(&amp;plock); NSLog(@&quot;线程2 将要执行,code = %d&quot;,code); sleep(2); NSLog(@&quot;线程2 执行结束&quot;); pthread_mutex_unlock(&amp;plock); }); // pthread_mutex_destroy(&amp;plock); } ​ 执行结果如下 12342017-04-28 00:14:11.692782 test[892:121163] 线程2 将要执行2017-04-28 00:14:13.698007 test[892:121163] 线程2 执行结束2017-04-28 00:14:13.698230 test[892:121192] 线程1 将要执行2017-04-28 00:14:16.700588 test[892:121192] 线程1 执行结束 NSRecursiveLock(递归锁)​ 此锁和NSLock的区别主要在于内部实现原理的不同，NSLock内部封装的pthread_mutex_t类型为PTHREAD_MUTEX_TIMED_NP，而NSRecursiveLock的类型为PTHREAD_MUTEX_RECURSIVE_NP，此外还有PTHREAD_MUTEX_ERRORCHECK_NP（检错锁）、PTHREAD_MUTEX_ADAPTIVE_NP（适应锁）。 ​ 递归锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。 ​ 该锁的使用场景主要是在递归函数内部调用。 ​ 按照惯例还是看个代码来说明下如何使用。 123456789101112131415161718192021222324252627282930313233- (void)testRecursiveLock{ NSRecursiveLock *recursive = [[NSRecursiveLock alloc]init];// dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_async(queue, ^{ [self getFactorial:10 cursive:recursive]; });}- (int)getFactorial:(int)n cursive:(NSRecursiveLock *)lock{ int result = 0; NSLog(@&quot;加锁&quot;); [lock lock]; if (n &lt;= 0) { result = 1; }else{ result = [self getFactorial:n-1 cursive:lock] * n; } NSLog(@&quot;result =%d&quot;,result); [lock unlock]; NSLog(@&quot;解锁&quot;); return result;} ​ 打印结果如下 1234567891011121314151617181920212223242526272829303132332017-05-02 00:43:08.241134 test[1194:551965] 加锁2017-05-02 00:43:08.241902 test[1194:551965] 加锁2017-05-02 00:43:08.241920 test[1194:551965] 加锁2017-05-02 00:43:08.241934 test[1194:551965] 加锁2017-05-02 00:43:08.241942 test[1194:551965] 加锁2017-05-02 00:43:08.241950 test[1194:551965] 加锁2017-05-02 00:43:08.241957 test[1194:551965] 加锁2017-05-02 00:43:08.241974 test[1194:551965] 加锁2017-05-02 00:43:08.241991 test[1194:551965] 加锁2017-05-02 00:43:08.241998 test[1194:551965] 加锁2017-05-02 00:43:08.242005 test[1194:551965] 加锁2017-05-02 00:43:08.242023 test[1194:551965] result =12017-05-02 00:43:08.242030 test[1194:551965] 解锁2017-05-02 00:43:08.242036 test[1194:551965] result =12017-05-02 00:43:08.242053 test[1194:551965] 解锁2017-05-02 00:43:08.242095 test[1194:551965] result =22017-05-02 00:43:08.242110 test[1194:551965] 解锁2017-05-02 00:43:08.242128 test[1194:551965] result =62017-05-02 00:43:08.242136 test[1194:551965] 解锁2017-05-02 00:43:08.242143 test[1194:551965] result =242017-05-02 00:43:08.242151 test[1194:551965] 解锁2017-05-02 00:43:08.242293 test[1194:551965] result =1202017-05-02 00:43:08.242309 test[1194:551965] 解锁2017-05-02 00:43:08.242317 test[1194:551965] result =7202017-05-02 00:43:08.242324 test[1194:551965] 解锁2017-05-02 00:43:08.242331 test[1194:551965] result =50402017-05-02 00:43:08.242338 test[1194:551965] 解锁2017-05-02 00:43:08.242344 test[1194:551965] result =403202017-05-02 00:43:08.242351 test[1194:551965] 解锁2017-05-02 00:43:08.242357 test[1194:551965] result =3628802017-05-02 00:43:08.242365 test[1194:551965] 解锁2017-05-02 00:43:08.242371 test[1194:551965] result =36288002017-05-02 00:43:08.242378 test[1194:551965] 解锁 NSCondition​ NSCondition 的对象实际上作为一个锁和一个线程检查器：锁主要为了当检测条件时保护数据源，执行条件引发的任务；线程检查器主要是根据条件决定是否继续运行线程，即线程是否被阻塞。 ​ 使用方式主要包括，lock，unlock, wait, signal,四个方法，分别指获取锁、放开锁、等待信号、发送信号。同样用一段示例代码来看下它的用法 1234567891011121314151617181920212223242526272829303132- (void)testCondition{ NSCondition *condition = [NSCondition new]; NSMutableArray *ops = [NSMutableArray array]; dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_async(queue, ^{ [condition lock]; NSLog(@&quot;1 将要上锁&quot;); while (ops.count == 0) { NSLog(@&quot;1 等待&quot;); [condition wait]; } NSLog(@&quot;1 移除第一个元素&quot;); [ops removeObjectAtIndex:0]; NSLog(@&quot;1 将要解锁&quot;); [condition unlock]; }); dispatch_async(queue, ^{ NSLog(@&quot;2 将要上锁&quot;); [condition lock]; NSLog(@&quot;2 生产一个对象&quot;); [ops addObject:[NSObject new]]; NSLog(@&quot;2 发送信号&quot;); [condition signal]; NSLog(@&quot;2 将要解锁&quot;); [condition unlock]; });} ​ 打印结果如下 123456782017-05-02 01:04:28.327316 test[1240:582713] 2 将要上锁2017-05-02 01:04:28.327329 test[1240:582712] 1 将要上锁2017-05-02 01:04:28.328121 test[1240:582712] 1 等待2017-05-02 01:04:28.328149 test[1240:582713] 2 生产一个对象2017-05-02 01:04:28.328166 test[1240:582713] 2 发送信号2017-05-02 01:04:28.328182 test[1240:582713] 2 将要解锁2017-05-02 01:04:28.328233 test[1240:582712] 1 移除第一个元素2017-05-02 01:04:28.328261 test[1240:582712] 1 将要解锁 至此，ios里面的大部分同步方法我们已经基本了解了，剩下的就是在实践中选择合适的方法进行应用了。 附录​ 如果有想查看DEMO的同学，可以点击它来下载DEMO，查看。 参考资料 iOS开发中的8种锁 深入理解ios开发中的锁 不再安全的OSSPinLock Threading Programming Guide Linux线程-互斥锁pthread_mutex_t iOS NSCondition详解","link":"/2017/05/02/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"},{"title":"译 ios并发编程指南","text":"并发编程指南 并发1 概述1.1 并发的概念并发其实指的是多项任务在同一时间进行，随着多核CPU的普及以及发现任务只在某一核上不停的增加，软件开发者需要一种方式充分的利用多核系统。虽然诸如IOS、MacOS兼容多项程序同时执行，但是大多数的程序运行在后台，并且执行任务只需要很短的CPU时间。这是因为前台应用同时获取了用户的关注并且是设备处于忙的状态。如果一个程序有很多的任务需要处理，但是又只获得了很少的碎片CPU时间，那些额外的处理资源将被浪费。 在过去，在应用中引入并发要求创建一个或者多个额外的线程，遗憾的是，编写线程代码是一项非常有挑战性的事情，线程是一种‘低级’的工具，并且需要手动去管理，获取多少个线程是最优的，动态取决于当前的系统以及底层硬件的支持。实现一个完美的线程解决方案，变的极其困难或者说不可能实现。另外，采取添加线程的方式实现同步的机制，不仅给软件开发带来了复杂性和风险性，而且也并不能确保提升性能。 OSX和iOS采取了一种比传统的基于线程的系统和程序，更加异步的方式去执行并发任务。并不是直接去创建线程，应用需要做的是定义一些特殊的任务，然后让系统去执行它们，让操作系统去管理线程，程序获得了原生线程更强的伸缩性，而程序开发者也获得了更加简单更加高效的编程模型。 本文档就是描述这项技术和技艺，你应该使用这项技术来实现并发。这项技术同时使用于iOS和OSX。 1.2 文档的组织本文档包括以下章节1、并发和程序设计——介绍异步程序设计的一些基本概念和异步的执行自定义任务的技术2、操作队列——展示怎样用OC去组装和执行一个任务3、分发队列——展示怎样在基于C的应用程序中去并发地执行任务4、资源分发——展示如何异步的处理系统事件5、从线程变成用迁移到新的技术——提供一些技术帮助从旧的线程变成迁移到新的变成技术 本文当同时也包括一些相关章节的专业术语的定义 1.3 一些专业名词在开始讨论并发之前，非常有必要去定义一些相关的专业名词来避免混淆，一些开发UNIX或者早先开发OSX的程序员，可能会对任务，队列处理、线程有一些新的任务，本文档对这几个概念有如下定义1、在本文中，线程专指一个分离的支线去执行一段代码，而在老的OSX中特指基于POSIX的API 2、在本文中，执行专指可执行的任务正在执行中，可能包裹着多个线程。3、在本文中，任务专指一个需要被执行的抽象工作 关于完整的类似这些概念的定义，参见词汇定义 1.4 其他本文档专注于如何在你的程序中实现并发编程，而不包括如何使用线程，如果你需要更多的有关线程开发的只是，请去参考线程编程指导 2 并发及程序设计2.1 并发编程和程序设计在以前的计算机运行的时候，计算机单位时间最大执行数量的任务取决于CPU的时钟速度，但是随着技术的发展和中央处理器设计的更加紧凑，热量和物理因素开始限制中央处理器的最大时钟速度，所以，主板供应商也在寻找其他的方式去提升他们主板的总体性能，他们发现的解决方案是增加主板上的处理器个数，通过增加处理器个数，一个主板可以在单位时间内执行更多的任务，而并不需要去增加CPU的时钟速度，或是改变主板的大小或考虑热量参数，现在剩下的唯一问题就是如何去充分的利用这些多核。 为了利用这些多核，计算机需要程序设计者能够去同时执行多项任务，在当代，多核操作系统，如OSX或者IOS，可能有几百或者更多的程序在同时运行，所以根据时序安排程序在不同的中央处理器上变得成为可能，然而，大多数的时候，这些程序要么是系统守护进程，要么是那些消费很小处理时间的后台应用程序，取而代之的是，真正需要多核开发的是，独立的前台运行的程序更高效的获取更多核心。 传统的使应用获取多核的方式是创建多线程，然而，随着多核的增加，线程方案有一些问题，最大的问题是线程开发的方式对多核系统不具备很好的伸缩性，你不能仅靠创建更多的行程就能确保程序和处理器运行良好，你需要知道的是，如何高效的利用这些中央处理器。对于程序来讲，如何计算它自身是一件有挑战的事情，尽管你可以正确的管理这些线程，程序去管理这些线程也依然是一项挑战，去确保他们高效运行、确保他们不被别的线程干扰。 所以，总结这些问题，程序需要一种方式去充分应用多核，单个程序可伸缩的执行大量工作，而且这个解决方案需要足够简单，去面对单个处理器任务的任务增长，好消息是，苹果已经提供了解决方案对处理所有这些问题，本章节先睹为快，去看看这项技术的组成以及牛逼的设计，你可以使你的代码从中获益。 2.2 从线程开发中走出来尽管线程开发已经应用了多年，而且它们在某些地方还将有用武之地，但是它们并没有可伸缩的解决多核场景，如果你使用线程开发，那么创建一个可伸缩的解决方案的麻烦就落在你肩上了，开发者，你需要去动态的根据系统的多核个数去决定创建多少个线程，此外，你的应用将花费很多消耗在创建和管理这些线程本身的消耗上。 取代线程开发，OSX和IOS使用异步设计的方式解决并发问题，异步方法已经在操作系统中提供了很多年，而且一般都是应用在创建很耗时的任务上，如从磁盘读取文件。当调用的时候，一个异步任务开始在后台执行，并立即返回在任务执行完之前。通常，这项任务会调用一个后台线程，开始这项任务在该后台线程上，然后在任务完成的时候发送一个消息给调用者（通常使用回调的方式）。在过去，如果没有一个你需要的异步方法，你需要自己去写一个异步方法还需要创建自己的线程，但是现在，OSX和iOS提供技术，你可以不用自己去管理线程就可以异步执行任务。 一种开启异步任务的技术叫 GCD，一项将过去需要在你程序中自己写管理线程代码移交给系统去管理。所有你需要做的事情仅仅是创建任务，然后将任务提交给合适的系统的GCD队列。GCD去创建和管理这些线程，因为这些线程已经提交给系统去管理，GCD提供全套的任务管理和执行，比传统的线程管理更加高效。 操作队列是非常类似于分发队列的一种OC对象管理方式，你可以定义你想执行的任务，然后把他们扔到操作队列中，当执行这些安排好的任务时，类似于GCD，操作队列为你执行所有的管理。确保在系统长执行的高效且迅速。 下面的段落提供了更多的信息关于操作队列、分发队列、以及一些你可能在异步编程中用到的技术 2.2.1 分发队列分发队列是一套C的机制，为可执行自定义任务。分发队列要么是串行的要么是并行的，但是通常都是按照FIFO的方式去调度任务，一个串行的队列，一次只能运行一个任务，只有等前一个任务完成之后，下个任务才能开启。作为对比，并行的队列可以同时开启尽可能多的任务而并不需要前面的任务执行完毕。 分发队列有下面几个好处 1、提供了简单的直观的编程接口 2、提供了自动的和完全的线程池管理 3、任务执行速度提升 4、更多的内存方面的优化 5、他们不会增加内核的负载 6、不会导致队列死锁 7、伸缩性强（对多核系统来讲） 8、串行队列提供了比过去线程同步更为优秀的一种选择 你提供给分发队列的任务必须是封装好的一个方法或者是一个Block对象，Block是一种具有C语言特性的，开始引进与OSX 10.6,IOS 4.0的一个新特性。但是相比C语言有一些别的好处。不同于在Block的语法区域定义Block对象，你通常在别的方法或者是函数中去定义，这样可以去捕获到别的方法或者函数中的变量，Block同样可以移动到他们的作用区域以外，拷贝到堆上，这通常发生在你将任务添加到一个分发队列上的时候，所有这些语法特性，使得通过添加少量代码就可以获得非常好的实现。 分发队列是GCD技术的一部分，也是C运行时的一部分，要想获取更多的有关分发队列相关的信息，请参见 分发队列，要获取更多关于Block的信息和他们的好处，参见Block 程序编程观点。 2.2.2 分发资源分发资源是异步的处理系统分发资源的一种C语言机制，分发资源封装了一个特殊类型的系统事件，并将这个特殊的系统事件提交给一个特殊的Block对象，或者函数，当系统事件发生的时候，你可以使用分发资源去监测如下特殊系统事件 定时器 信号事件 描述符相关事件 进程相关事件 端口匹配相关事件 自定义的事件，并由你来触发 分发资源也是GCD技术的一部分，要获取更多有关分发资源相关的信息，参见分发资源 2.2.3 操作队列操作队列是cocoa环境的一种并发队列，由NSOperationQueueClass 实现，操作队列总是按照FIFO的方式去执行任务，操作队列考虑其他因素去影响执行队列的顺序，在这些因素中，优先考虑一个任务的执行是否是依赖于其他任务，你可以给自己的任务设置依赖关系，然后创建一个复杂的执行顺序图。 任务添加到操作队列中的，必须是NSOperation的子类，一个操作对象是一个OC类型的封装了你要执行的数据和任务的对象，由于NSOperation是一个抽象基类，所以你通常需要去自定义子类去执行你的任务，然而，Foundation Framework已经提供了一些相关的子类，你可以使用它们去执行任务。 操作的对象产生KVO通知，这个是非常有用的，当监视你的任务进度的时候，虽然任务执行通常是并发的，但是可以利用依赖是的任务有序。 关于更多操作队列的信息，参见操作队列 2.3 异步编程技术在你开始考虑重新用并发编程的方式重新设计程序的时候，你最好先问下自己这么做是否必要，并发可以提高你代码的可响应性，去确保主线程能相应更多的用户事件，它同样可以提高你代码的性能，通过促进多核去执行更多的任务，但是它也同时带来了上层复杂性，从而使你的代码更加难调试。 由于它带来了复杂性，并发并不是一个在你程序开周期中考虑的特性，当把它嫁接到应用中。做对这件事需要你好好考虑你程序执行的任务以及向这些任务提交的数据结构。如果做错的话，你可能发现你的代码运行缓慢，甚至还不如从前，因此，在你开始程序设计的时候，你就应该考虑你要实现的目标和通过何种方式来达到它。 每个应用都包含有不同的要求和不同的任务需要它去执行，这不可能靠一个文档就告诉你，怎么去设计你的程序和管理任务，然而，下面几段可以给你提供一些指导，帮助你去在程序设计的时候做出好的选择。 2.3.1 明确程序期望的表现在你决定是否要将并发引导到应用中的时候，你应当开始思考你的应用程序想要达到的一个什么表现。明白了应用要达到的表现之后，会给你是否使用并发提供一个参考。同样的，也会给你一些引入并发之后程序能获取的性能收益方面的启发。 首先、你需要列举应用程序所要执行的任务和数据结构之间的关系。开始，你可能通过点击一个菜单或者一个按钮开启一个任务并执行，这些任务可能是一些离散的任务，并有明确的开始和结束点。你还需要列举出应用程序可能执行的其他类型的任务，而不仅仅是用户行为相关的，比如说基于时间的一些任务 在你有了自己任务列表之后，开始把任务进行更加的分组集合，确保这些任务能够成功执行。在这个层面，你优先考虑的是那些数据或对象修改如何对应用状态进行修改的。你同样需要考虑不同任务之间的相互依赖关系，例如：如果一个任务牵涉到一个数组中所有对象的修改，对于其中一个数据的修改，会对其他数据产生任何影响。如果一个数据的修改，独立于其他的数据，那么这个时候你可以考虑使用并发去做提升性能，创建多个任务去做。 2.3.2 单位工作的可执行因子在明白你程序执行的任务类型之后，你应该明白在什么地方去使用并发会有好处了。如果在一个任务中改变一个或者多个的顺序，会影响到执行结果。你应该还是需要考虑到使用串行的方式去执行这些任务，如果改变执行顺序之后，并不会影响到执行结果，你可以考虑将这些任务用并发的方式去做，在这俩种情形下，你定义可执行的单位工作，并让它们执行，这些工作单元，就成为你封装好的Block对象或者操作对象或者分发队列。 对于每个单独的可执行任务，并不需要过多的担心任务执行的数量，在最后，分到线程中总是会有开销，但是分发队列或者操作队列相比传统的线程开发还是有很多优势的，因此，执行一些单元工作使用操作队列还是要比直接操作线程要好很多，当然，你常常应该确保任务执行的性能和你开启的任务恰好如你所需，但是，任务并不是越小就越好。 2.3.3 区分你需要什么队列此时，你的任务已经切割为一些可执行的单元，并且封装成了Block对象或者是操作对象，你需要去定义你要执行的队列以执行这些任务。对一个任务来讲，测试这些Block或者是操作任务，能够在队列中执行正确。 如果你使用Block去实现你的任务,你可以添加任务到串行或者并行的队列里，如果对顺序有要求的话，你只能添加到一个串行队列中，如果没有要求，根据你的要求，你可以添加的并行队列中，或者添加到多个队列中去。 如果你是用操作队列去执行任务，那么选择的队列并不对添加到里面的任务的配置感兴趣，如果要串行去执行任务，那么你需要给相关的任务设置依赖关系，依赖会阻止任务开始执行，直到它依赖的任务执行完成。 2.3.4 提升执行效率的贴士在把任务分割为更小的任务并将他们添加到队列中后，这里还有一些使用队列提升程序性能的小Tips 如果内存考虑是一个因素的话，那么在任务里面直接计算。如果你的应用已经内存警告了，那么在任务中直接计算会比从内存中加载要快一些。运用在寄存器或者是该核上的内存计算，会比从主内存加载要快一些。当然，你也可以通过测试来选择哪种方案会好一些。 将串行的任务，可能的话改变为并发。如果一个任务由于共享资源必须串行去执行，可以考虑将共享资源移除使得可以并发执行，可以考虑把这些资源给每个客户都拷贝一份。 避免使用锁，操作队列和分发队列的支持在大多数情况下并不需要锁。做为取代，可以使用一个串行的队列或者使用依赖去保证顺序正确。 如果可能的话依赖系统框架，最好的方式去实现并发就是使用系统提供的框架，许多框架使用线程或者其他技术来实现并发，当定义你的任务的时候，看看系统框架中是否已经有方法或者函数能够实现并发，使用系统接口会提升你的效率，而且帮你做到更多的并发可能性。 2.4 性能相关操作队列、分发队列、资源分发提供了一种执行并发更加容易的方式。但是这些技术并不保证提升程序的性能和可响应性。具体来讲，根据你的需要同时兼顾性能提升和不要影响到其他资源仍然是你自己需要衡量的一件事。举个例子来讲，尽管你创建了10000个任务并把他们都提交到操作队列中，这么干的话，肯定会导致你的程序分配潜在的大量内存，这个会导致增加调度和减少性能。 引入并发到你的程序中前–是使用队列还是线程，你需要根据程序当前的性能来设置一个参考的标准。在引入并发之后，也同样需要做个列表对性能方面的改变进行比较，来确保程序是真的性能提升了，如果引入并发并不能给性能带来大的提升，你应该考虑其他的性能工具来检测潜在的原因。 关于性能的介绍和可用的性能工具，参见性能概览。 2.5 并发和其他技术将你的代码分解为模块任务是一种最好的提升应用并发的方式，但是这种设计方式并不是对每个应用每个情况都很适合，取决于你执行的任务，也可能存在其他的选择来提升程序的整体并发，下面的俩小节提供了其他的并发技术供你参考 2.5.1 OpenGL和并发在OSX中，OpenGC技术是图形计算方便最基础和核心的技术，OpenGL是非常棒的计算大数据集合的一种技术，举个例子来讲，你可能使用OpenGL技术来给图片做像素级别的滤镜，或者用它来计算复杂的数学计算。换而言之，OpenGL可以用来计算大量数据集合是并行的。 尽管OpenGL在大量数据并行执行方面有着非常好的性能优势，但是它并不合适执行自定义的计算，在任务提交给GPU处理之前，有大量的准备工做，而且要将数据和其他必要的核心操作转换图形卡片。同样的，要想获取OpenGL的产生结果也需要偶很多其他的努力。因此，所有跟系统交互相关的任务不建议提交给OpenGL去执行，举个例子，你不应该用OpenGL去运算从文件中或者网络流中拿到的数据，取而代之的是，你要用OpenGL执行的任务，必然是自己已经持有的这样相对来讲传递给GPU运算更加独立。 更多关于OpenGL的只是，参见OpenGL开发指导。 2.5.2 何时使用线程尽管操作队列和分发队列是执行并发任务的更优选择，但是它们不是万能的，取决于你的应用程序，这里仍然后一些情况是需要创建线程去开发的，如果你创建了自定义的线程，那么你要确保尽量少的开启线程，并且确保这些线程只执行特定的任务，而不去干别的事情。 线程仍然是一种较好的解决方案，当执行实时任务的时候，分发队列会确保尽快的去执行他们的任务，但是并不能实时的去开线程去做。如果你需要可预测的后台代码执行，那么线程仍是一种选择。 作为线程编程，你还是需要去使用线程，当必须和完全必要的时候，关于更多线程方面的知识，参见线程开发指导。 3 操作队列cocoa的操作都是原生的对象封装的可执行异步任务。这些操作同时可提交给操作队列去执行，也可以直接自己执行。由于是基于OC的框架，那么操作可应用在IOS和OSX中。本章节将介绍如何去使用和定义操作。 3.1 关于操作对象一个操作对象是一个NSOperation类的实例，你可以用它来封装你要执行的任务。NSOperation类本身是一个抽象基类。所以要想执行可用的任务，必须得使用它的子类。尽管是一个抽象类，它还是提供了一些有用的基本操作，而省去了你在自己定义的子类中去做的麻烦。此外，Foundation 框架还提供了俩个具体的子类，可以用它们来执行你的任务，下表列出了这俩个类，还有如何使用它们的介绍。 NSInvocationOperation ：这是一个基于你的类和要执行的Seletor的类，你可以在已经定义过这个任务的地方去调用它，然后执行异步操作。由于它并不要强制你去做继承，所以可以使用该类去实现一个更加动态的风格。 NSBlockOperation：这是一个执行block封装任务的操作类，因为它可以执行多个block。block任务执行任务使用了组的语法，当所有的相关的block执行完之后，这个block操作才被任务是执行完成 NSOperation：这是定义其他操作任务的基类，继承它给你自定义操作类带来了完成的并发控制以及实现。包含可以完全控制任务的执行能力和执行状态。 所有上述的操作对象都包含以下核心的特性 支持建立图形化的任务间相互依赖，这些依赖将会阻止任务开始，直到它依赖的任务完成之后。 支持可选的完成回调block。指的是当所有的执行任务结束之后的回调方法。 支持检测任务执行状态（使用KVO） 支持对操作顺序进行调整，并影响他们的执行顺序。 支持取消语义，也即允许你半路对任务执行终止操作。 操作对象是设计来帮助你提升程序的并发水平，操作也是一种不错的组织和包装你的应用为几个独立的分支的一种手段，作为取代提交一些任务给主线程的开发方式，可以将任务分割为一个或多个不同的操作，然后提交给队列，使相关的工作可以在一个或多个线程中去并发的执行。 3.2 同时VS非同时操作尽管，你通常将任务添加到操作队列中，但是做这个并不是必须的。你也可以直接调用它的start方法去开始一个操作。但是执行这个操作，并不能保证你的操作同步的运行在你当前代码所在的线程中。那么NSOperation类的这个isConcurrent方法会告知你，当前运行的操作是同步还是异步的在你调用Start方法的线程中，默认情况下这个方法会返回NO，也就是说这个操作是在当前调用的线程中同步去执行的。 如果你想去实现一个异步执行的操作，也就是调度任务的线程和任务执行的线程是异步的。你需要写额外的代码去异步的开启它。举个例子，你可以创建一个独立的线程，调用一个系统的异步方法，去执行其他的事情以保证start函数的调用时异步去执行。 大多数的开发并不需要去实现一个并发操作对象，如果你总是将你的操作去添加到一个操作队列中，你并不需要实现这些并发操作，当你添加一个操作对象到操作队列中的时候，操作队列自己就会创建一个线程去执行你的操作，因此，将一个并不是异步的任务添加到操作队列中去，结果还是会以异步的方式去执行代码，去定义一个异步任务这种费力不讨好的工作，也只是你就是想创建异步执行任务，而不是将它添加到队列中去的时候才有必要。 关于更多有关异步任务的信息，参见设置任务去异步执行。 3.3 创建一个NSInocationOperation对象NSInvocationOperation是NSOperation的具体子类，当它运行的时候，会执行它的selector里面，指派给它的任务。使用该类时，应该避免将大量的自定义的操作给每个任务。尤其是当你需要改变一个已经存在的应用程序和这些对象已经存在任务，还有很多必备要执行的任务时。你可以使用它来改变依赖环境的时候。举个例子，你可以使用一个Invocation对象来执行一个选择器，这个选择器是基于获取用户的输入信息动态的选择。 创建一个Invocation操作的步骤是很简单的，你可以创建并实例化一个该对象，然后传递需要的对象和selector去执行指定的代码，下面提供了俩个方法去举例说明这个操作步骤，taskWithData：方法创建一个操作对象，然后通过另外一个方法去执行任务。 123456789101112@implementation MyCustomClass - (NSOperation*)taskWithData:(id)data { NSInvocationOperation* theOp = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(myTaskMethod:) object:data]; return theOp; } // This is the method that does the actual work of the task. - (void)myTaskMethod:(id)data { // Perform the task. } @end 3.4 创建一个NSBlockOperation对象NSBlockOperation是NSOperation的具体子类，作为一个或者多个Block对象的封装器，这个类提供了对象层面的封装，而且它已经使用了操作分发队列，所以并不需要创建分发队列，但是你也可以使用其他的诸如操作任务的依赖、KVO通知或者其他特性，而这些特性是分发队列所没有的。 当你创建一个block操作的时候，在创建他的时候，你至少已经添加了一个block，你也可以在之后再添加更多的block进去。当执行NSBlockOperation对象的时间来临的时候，该对象会将它的所有block都提交给默认优先级的异步分发队列，然后这个对象等待它的block全部执行完，之后会把自己标记为isfinish。因此，你可以使用一个Block操作去监听一组任务的完成，非常像用一个线程去管理多个线程的结果。而不同之处在于block操作自己运行在一个分离的线程，而你的程序可以干其他的活儿，在这个block等待它的任务执行完成之前。 下面的代码介绍了如何去创建一个BlockOperation，这个Block没带参数且没有返回什么有意义的结果 NSBlockOperation* theOp = [NSBlockOperation blockOperationWithBlock: ^{ NSLog(@”Beginning operation.\\n”); // Do some work. }]; 当创建一个block操作之后，你可以添加更多的block给它，通过 addExecutionBlock：方法，如果你想让添加的任务线性去执行，那么你必须直接将它提交给指定的串行队列中去。 3.5 定义一个自定义的操作如果一个Block操作对象或者Invocation操作对象没法完全满足你的需求的时候，你可以考虑自己定义个继承自NSOperation的操作对象，NSOperation对象提供了一系列的继承点给所有的操作对象，这个类已经实现了大量的基础的函数或方法，满足那些依赖或者KVO的操作，然而，还是有一些地方需要你自己的自定义实现确保你的操作对象能够正确的执行，具体的工作量的大小取决于你要自定义的是一个同步操作对象还是异步操作对象。 定义个同步操作对象要比定义一个异步操作对象简单的多，对于一个同步操作对象来讲，所有你要做的工作就是实现main执行函数和响应取消操作事件。父类已经帮你做了所有其他该做的工作，而对于一个异步操作对象来将，你需要替换一些父类已经做过的工作，在你自己定义的操作对象上。下面的俩小节将介绍如何去实现这俩种不同的操作对象。 3.5.1 执行main任务至少一个操作对象需要实现下面的函数 一个自定义的初始化函数 main 你需要自定义个初始化函数去初始化一个操作对象，以及一个自定义的main函数去执行任务，你也可以根据需要执行其他的函数，如下所示 自定义函数供你的main函数去调用 属性方法去访问数据 实现NSCoding协议去固化一个操作对象 下面的模板，展示了一个自定义的操作对象，下面的代码并不展示如何去实现取消方法，但是也实现了你通常要实现的方法，具体怎么取消任务，参见取消任务介绍，下面的初始化函数初始化了一个对象，携带一个数据参数并把它存到了类内部方便以后访问，main函数将会显式的去操作这个对象，在你的应用将结果返回给你之前。 123456789101112131415161718192021@interface MyNonConcurrentOperation : NSOperation@property id (strong) myData; -(id)initWithData:(id)data;@end @implementation MyNonConcurrentOperation - (id)initWithData:(id)data { if(self = [super init]) myData = data; return self; }-(void)main { @try { // Do some work on myData and report the results. } @catch(...) { // Do not rethrow exceptions. } } @end 更多的细节参见NSOperationSample 3.5.2 响应取消事件当一个操作开始执行的时候，它将持续执行任务直到结束或者任务被显式的取消掉，取消操作可能发生在任何时候，甚至是操作开始执行的时候，尽管NSOperation对象提供了一个方式供子类去使用，指出取消事件是完全必要的。如果一个操作完全结束了，那么也可以提供一个方式去清理之前分配的资源等等，所以，一个操作对象需要去检测是否已经取消了，然后就可以优雅的结束任务。 操作对象支持取消操作，你应该做的事情就是频繁的去检查是否任务已经被取消了，支持取消是非常重要的，对于你自定义的任务和系统给的那俩个子类操作对象来说，isCancel方法是非常轻量级的，可以频繁去访问而不会造成内存方面的空扰，当设计一个操作对象的时候，你可以在如下几个地方去访问iscancel 1、在你开始执行任务之前 2、在开启一个loop之前，或者是更加频繁的在每个循环之前 3、在你的每个可能导致任务退出的地方 下面的代码介绍了在main函数中如何去调用cancel，在这个例子中，iscancel在每次while loop前都会调用，使得任务可以快速的退出，且获取了一个定期的间隔。 12345- (void)main { @try { BOOL isDone = NO; while (![self isCancelled] &amp;&amp; !isDone) { // Do some work and set isDone to YES when finished } } @catch(...) { // Do not rethrow exceptions. } } 尽管上面的代码，并不包含清理数据的工作，但是你自己的代码还是要保证资源被及时的释放。 3.5.3 定义一个可并发执行的操作一个操作对象默认情况是按照同步的方式去执行任务，也就是说他们执行任务的线程也就是start调用的线程。因为操作队列会对操作任务提供开启的线程，因此，大多数的任务就会异步运行，然而，如果你计划手动去执行一个任务，而且还希望这个任务异步的去运行，你必须得采取一些手段来保证能够这么干，你需要把你的操作对象定义为一个可并发执行的操作对象。下面列出来的函数就是你需要重写的并发操作。 start：（必须重写）所有的自定义并发操作必须重写这个函数，从而替换之前这个函数的默认实现。要手动的执行一个操作，你就可以调用start函数，因此从，你对该方法的实现就是自定义操作对象的开启任务的节点，也就是你要提交你的任务到线程中去执行的节点，你的实现在任何时候都不应该去调用super start。 main：（可选的）这个函数通常用来实现与操作对象相关的任务。虽然你可以把执行任务的任务放到start中去执行，利用mian方法去执行任务会对你的任务开始和清理工作有好处。 isExecuting：（必须的） isFinish：（必须） 并发操作非常有必要向使用它的客户报告配置环境和执行状态，因此一个并发操作必须得包含执行的状态信息包括何时开始执行任务，何时结束任务，如果要报告状态，那么必须使用这些方法。 当别的线程在同时调用上述方法的时候，你必须得保证这些方法是安全的。同时，你也必须得实现KVO通知，以报告这些状态。 isConcurrent：（必须）区分一个操作是否是并发操作，重写该方法，并返回YES 本小节的剩余部分将展示一个MyOperationClass的例子，这个类列举了实现一个并发操作的基本函数，MyOperation 类将在它自己开启的线程中执行任务，而正在的执行任务将与操作类是不相干的，下面例子将的几点，就是你在定义一个并发操作时需要提供的一些基础函数。 下面的代码显示了部分MyOperation的接口和实现函数，这些实现包括isConcurrent、isExecuting，isFinish，等函数。其中isConcurrent函数非常简单，只需要返回YES去指明本操作是一个并发操作就可以了，isExecuting 和 isFinished 也比较简单，返回在类中存储的成员变量的值就可以了。 1234567891011121314151617181920@interface MyOperation : NSOperation { BOOL executing; BOOL finished; }- (void)completeOperation;@end @implementation MyOperation - (id)init { self = [super init]; if (self) { executing = NO; finished = NO; } return self; }- (BOOL)isConcurrent { return YES; } - (BOOL)isExecuting { return executing; } - (BOOL)isFinished { return finished; } @end 下面的方法展示了MyOperation的 start函数，下面的实现是一个start函数，执行任务至少要实现的内容。在这种情况下，start函数简单的开启一个新的线程，然后让这个线程去调用main函数。这个函数同样要更新executing成员变量，而且要对isExecuting关键路径产生KVO通知，当这些工作完成之后，就会离开函数，并去到新的线程中去执行任务。 12345678- (void)start { // Always check for cancellation before launching the task. if ([self isCancelled]) { // Must move the operation to the finished state if it is canceled. [self willChangeValueForKey:@&quot;isFinished&quot;]; finished = YES; [self didChangeValueForKey:@&quot;isFinished&quot;]; return; }// If the operation is not canceled, begin executing the task. [self willChangeValueForKey:@&quot;isExecuting&quot;]; [NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil]; executing = YES; [self didChangeValueForKey:@&quot;isExecuting&quot;]; } 下面展示了MyOperation剩下的实现，在上面的代码已经知道 main函数将作为新的线程开启任务的节点，它将执行操作对象带来的任务，并且要执行completeOperation函数来说明任务已经结束，completeoperation函数将对isExecuting和isFinished关键路径发送KVO通知，来反应操作对象的状态已经改变。 1234567891011121314151617- (void)main { @try { // Do the main work of the operation here. [self completeOperation]; } @catch(...) { // Do not rethrow exceptions. }} - (void)completeOperation { [self willChangeValueForKey:@&quot;isFinished&quot;]; [self willChangeValueForKey:@&quot;isExecuting&quot;]; executing = NO; finished = YES; [self didChangeValueForKey:@&quot;isExecuting&quot;]; [self didChangeValueForKey:@&quot;isFinished&quot;]; } 尽管是操作对象被取消掉了，你也应该发送KVO通知，来通知你的任务已经完成，当一个操作对象的执行时依赖其他操作对象的时候，它将检测isFinished状态，只有当它依赖的所有isfinished状态都变为YES的时候，如果无法发送isFinshed通知将会阻止其他依赖他的操作对象的执行。 3.5.4 维护KVO的兼容NSOperation类是服从下列关键字的KVO isCanceled isConcurrent isExecuting isFinished isReady dependencies queuePriority completeBlock 如果你重写了start函数，和自定义了一些其他比较重要的函数，而不是单单重写main函数，你必须保证自定义的对象能够响应KVO，当重写start函数，其中你最需要关注的就是isExecuting和isFInished，这里有大量的方法会受到这俩个函数的影响。 如果你想实现支持依赖关系，以对其他一些操作对象的时候，你也可以重写isReady函数，并强制返回NO，直到你自定义的依赖关系满足。（如果你仍然想支持系统提供的依赖关系的时候，请保证调用super的函数）当你操作对象的isReady状态发生变化的时候，请发送KVO通知去报告这个状态，不过幸运的是，除非你去重写addDependency和removeDependency:，你并不需要担心KVO通知的发送。 虽然你可以发送其他关键字的KVO通知，但是通常你并不需要这么做，如果你想取消一个任务，你可以简单的调用cancel函数就好了。同样的，你也不需要去修改队列的优先级在操作对象上，最后，除非你的操作对象支持动态的修改isConcurrent，你也不需要发送KVO通知给isConcurrent关键路径。 如果要知道更多关于KVO的操作，请参见KVO编程指导。 3.6 自定义一个操作对象的执行行为在添加一个操作对象到操作队列里面之前，需要将一个操作对象设置好，这些对操作对象设置的信息将会对所有的操作对象有效，不仅是自定义的操作对象，还包括系统定义的那俩个操作对象。 3.6.1 设置依赖关系依赖是一种限制操作对象执行顺序的一种手段，一个操作对象的执行，必须得在它依赖的所有对象执行完成之后才能进行。也就是说，你可以创建简单的一对一的或者是负责的依赖关系树。 在俩个操作对象之间创建依赖关系，你可以使用addDependency：方法，这个方法可以在你传的目标对象和自己之间创建一个依赖关系。也就是说在目标对象没有执行完成之前，你的这个对象是不会执行的。依赖还不仅仅限制在一个操作队列中，因为是操作对象管理依赖关系，所以在不同的操作队列之中，依赖也是可以起到作用的。但是有一种情况是不允许的，那就是设置依赖环，这是一种语法错误，会导致任务永远得不到执行。 当操作对象所依赖的所有操作对象都执行完成之后，操作对象就变成ready状态，准备执行。（如果是你自己定义的操作对象 ，并自定义了isReady函数，那么准备状态就和你设置的条件有关系了）如果一个操作对象是在操作队列中，那么isReady状态的操作对象在任何时候都可能被执行，如果你计划手动去执行一个操作对象的话，那么可以调用他的start方法。 重要:你应当在将操作对象提交到操作队列之前就去设置依赖关系，如果在之后去设置依赖，也许将不会阻止该任务的执行。 依赖基于的是操作对象间在任何时候都可能发生变化的KVO通知，如果你自定义了操作对象的话，你需要自己去发送KVO通知，以防出现依赖方面的问题。关于更多KVO的信息，参考维护KVO兼容，关于更多设置依赖的信息，参考NSOperation 类 3.6.2 改变操作对象的执行优先级对于添加到队列中的操作对象，是否能够执行，首先是受操作对象的isReady状态控制，其次是他们的优先级，是否准备好执行，是由操作对象的依赖对象是否执行完来限制的，但是这个优先级是操作对象的一个属性值，默认情况下，所有新创建的操作对象都是普通优先级，但是你可以增加或者是减少操作对象的优先级，通过setQueuePriority方法 优先级只对同一个队列中的操作对象起作用，如果你的应用有多个操作队列，不同队列中的操作对象的优先级是相互独立的，也就是说，在不同队列里面，存在低优先级的操作比高优先级的操作先执行。 优先级并不是依赖的替代，优先级决定的是那些在队列中已经是准备状态的操作对象的执行顺序，举个例子，如果一个队列中同时有高优先级和低优先级的操作对象准备好了，那么操作队列先执行高优先级的操作对象，然而，如果高优先级的没有准备好，但是低优先级的准备好了，那么将先执行低优先级的，如果你想阻止一个操作任务在另外一个操作对象执行完之后再执行，你需要使用依赖关系去 做 3.6.3 改变依附线程的优先级在OSX 10.6及以后，设置一个操作对象所在的线程的优先级成为可能，系统的线程策略是依靠内核去管理，但是高优先级的线程将获得更高的执行机会，对一个操作对象，你可以显式的指定它的线程优先级，通过设置一个浮点型的数值，0-1.0之前。0是优先级最低、1是优先级最高。如果不显式设置的话，系统默认的线程优先级是0.5. 要设置线程优先级的话，你需要在讲操作对象添加到操作队列之前，调用setThreadPriority函数。当它的执行时间到来的时候，默认的start函数就会设置你之前指定的线程优先级来修改优先级。这个优先级只在你执行的main函数执行过程用有效。所有的其他代码包括你的完成回调，仍然是运行在默认的优先级下的。如果你自定义了一个并发的操作，那么你需要重写start函数，并手动去修改线程的优先级。 3.6.4 设置一个完成后的回调block在OSX 10.6及以后，一个操作对象可以在它的所有任务执行完成之后去执行一个完成的block，你可以用这个完成的block执行任何与main函数执行的任务里面不相关的的block。举个例子，你可能需要告诉客户这个操作对象的任务都执行完成了，一个并发的操作对象可能会使用这个block去执行它最后的KVO通知 要设置一个完成block，你可以使用setCompleteBlock：函数，这个函数不需要传任何参数，也没有返回值。 3.7 关于实现一个操作对象的一些Tips尽管一个操作对象可能非常容易去实现，但是有一些事情在你自定义的操作对象上还是要注意一下，下面的小段描述了这么几个方面。 3.7.1 管理操作对象的内存下面的小段，描述了几个在操作对象中管理内存的关键元素，关于更多的OC的内存管理，参见内存管理开发指导。 3.7.1.1 避免依靠线程存储数据尽管大多是的操作都是在一个线程中执行的，在同步操作对象中，这个线程通常是由操作队列分配给它的，如果一个操作队列将线程分配给操作对象，那么你需要知道这个线程它是属于操作队列的，你不应该和你的操作对象有任何瓜葛，尤其是，你不应该有任何数据相关的在这个线程中，而这些数据并不是你创建和管理的数据，因为线程的生存和死亡是有操作队列或者系统来控制的，因此在线程间数据传递通过线程来传递将是不可靠，也是容易失败的。 在操作队列上，没有任何的理由可以使用线程存储数据，当你初始化一个操作对象，你应该提供给它所有执行任务需要的数据去做这件事，因此，操作对象要提供所有数据，所有来的、去的数据都应该存在操作对象上，知道任务结束或者应用不在需要它。 3.7.1.2 如果需要的话保持操作对象的引用因为操作对象是异步运行的，你不应该认为你可以创建或者忘记他们，它们也只是对象而已，也需要你去管理他们，尤其是你需要在它完成之后获取数据的情况下。 你需要保持对操作对象的引用，主要还有可能你再没有机会获取这个操作对象的引用的机会了，操作对象是执行很快的，在很多情况下，操作任务一旦添加到操作队列中，就会被执行，当你的代码获取到从操作队列中拿到的操作对象的时候，很可能，这个操作对象已经结束了，并从操作队列移除了，释放了。 3.7.2 处理错误和异常由于操作对象在你的应用里面是完全独立的实例，因此有必要去处理那些异常和错误，在OSX 10.6及以后，默认的start的函数不在提供捕获异常。你自己的代码需要去直接的捕获和处理异常，如果需要也要检测错误代码并通知给应用程序，如果你替换了start函数，那么你的代码需要在程序离开底层线程之前就去处理这些异常。 你可能处理的错误可能有一下几种情况 检测UNIX errno 类型的错误 检测显式的由代码返回的错误 捕获来自你自己的代码和系统框架带来的异常 当一个操作对象没有准备好，start方法就开始执行的时候 当一个操作已经在执行或者执行完成了，或取消了，start函数被再次调用的。 当添加一个block任务，但是它已经被执行或者完成的。 当你准备从NSInvocationOperation对象获取数据，但是它已经被取消的情况。 如果你自定义的代码遇到异常或者错误，你需要提供操作步骤给你的应用去处理，Operation对象不会显式的把错误代码或者异常传递给你应用的其他地方，因此，如果对于应用程序是比较重要的信息，你需要提供相关必要的代码去处理这些错误。 3.8 决定操作对象合适的数量，不要太多，也不要太少虽然可以给一个操作队列中，添加大量的操作对象，但是这么做，往往并不太好，像其他对象一样，创建NSOperation对象也是需要消耗内存，并且他们的执行也是需要开销的。如果你的每个任务都是很小的，而你又创建了成千上万个，你会发现你会消耗更多的时间在分发操作对象上，而不是在执行真正的任务，而如果你的设备已经内存不足时，你会发现成千上万的任务会严重影响程序的性能。 高效的应用操作对象的关键在于，在充分利用设备和执行一定数量的操作任务之间找到平衡点，尝试去找到你的设备执行任务的一个真正的数量值。举个例子，如果你的应用创建了100个操作对象去处理100个不同的值，那么你可以考虑使用10个操作对象，去处理10个值去代替。 同时，你也需要避免一次性的给操作队列中添加大量的任务，也要避免不停的给操作队列以比它处理速度更快的添加更多的任务，相比于一次泛哄式的添加任务，不如批量式的去添加，然后利用完成block回调去执行下一批次的任务。这样可以避免内存过多的消耗。 当然，创建操作对象的数量、以及没个操作对象需要执行的任务量，是由你的程序动态去管理的。你应该是用性能测试工具，例如Instruments去找到性能处理和速度的平衡点，关于Instruments 和其他性能工具的更多信息，参见性能。 3.9 操作对象的执行最后，你的应用需要执行这些操作对象以真正的处理任务，在这一小节，你将学到就像你熟练的执行你的操作一样，去执行这些操作。 3.9.1 添加操作对象到操作队列中到目前为止，最容易的执行操作的方式是使用操作队列，即NSOperationQueue类的实例，你的应用有责任去创建和维护这些操作队列。一个应用程序可以有任意数量的操作队列，但是实际上在同一时间有多少个操作会被执行还是有限制的，被系统调用的操作队列会根据可利用的CPU和系统的载入量来进行限制单位时间执行的操作对象，因此，创建更多的操作队列并不意味着可以执行更多的操作对象 就想创建其他的对象一样，在你的应用中创建操作队列 1NSOperationQueue* aQueue = [[NSOperationQueue alloc] init]; 添加一个操作对象到操作队列中，你可以使用addOperation方法，在OSX 10.6以后，你还可以添加操作对象组，通过 1addOperations：waitUntilFinished： 方法，你也可以直接添加blocl对像到操作队列中（而不需要与一个操作对象关联），通过 1addOperationWithBlock： 方法，上面的这些方法，队列都会入一个操作对象并通知队列去执行他们，在大多数情况下，操作对象将会被很快执行，但是有时候，操作队列也可能延迟执行操作对象，大概有这么几个原因，最普遍的就是，操作对象间可能有依赖关系，还有可能是操作队列自己可能被挂起，或者是操作队列执行操作任务的数量达到了上限。下面的代码展示了最基础的添加操作到操作队列的语法 1234[aQueue addOperation:anOp]; // Add a single operation [aQueue addOperations:anArrayOfOps waitUntilFinished:NO]; // Add multiple operations [aQueue addOperationWithBlock:^{ /* Do something. */ }]; 重要 千万不要在一个操作对象进入操作队列之后再去修改它，因为当操作在操作队列中等待执行的时候，它可能在任何时候去执行任务，改变它的依赖和数据，可能会起到坏的作用。如果你想知道一个操作对象的状态，请使用操作对象的属性 去获取。 3.9.2 手动执行操作对象尽管操作队列对于运行操作对象已经很方便了，但是还是有一种可能不使用操作队列去执行一个操作对象，如果你选择手动去执行操作对象，那么有一些注意事项，最主要的是，操作对象必须得是ready，而且你需要用start函数去启动它。 一个操作对象如果不是ready状态的话不应该去执行，isReady函数被Operation对象的依赖关系封装到了上层，只有当它的依赖关系都清除的时候，一个操作才能够被执行、 当执行一个操作对象，应该去使用start函数去做。用这个函数而不是用main，是因为start函数会在执行之前执行一个安全检查，尤其是，默认的start函数还会产生KVO通知，以保证依赖关系能够正确进行，这个函数同时也避免当你的操作对象被取消的时候，再去执行，以及当操作对象没有准备好的时候就去调用导致的异常抛出 。 如果你的程序定义了并发的操作对象，你同时需要在启动任务之前考虑isConcurrent。当这个方法返回NO的时候，你就可以考虑是在当前线程中同步的执行还是创建一个新的子线程。然而，这些方法的检测完全取决于你。 下面展示了一个比较简单的，手动开启并发操作对象的一个例子。如果这个函数返回NO，你可以启动一个timer，在之后再去调用它。然后直到它返回YES之后，取消掉Timer。因为这种情况可能在操作对象被取消的时候发生。 1234567891011121314151617181920- (BOOL)performOperation:(NSOperation*)anOp { BOOL ranIt = NO; if ([anOp isReady] &amp;&amp; ![anOp isCancelled]) { if (![anOp isConcurrent]) [anOp start]; else [NSThread detachNewThreadSelector:@selector(start) toTarget:anOp withObject:nil]; ranIt = YES; }else if ([anOp isCancelled]){ // If it was canceled before it was started, // move the operation to the finished state. [self willChangeValueForKey:@&quot;isFinished&quot;]; [self willChangeValueForKey:@&quot;isExecuting&quot;]; executing = NO; finished = YES; [self didChangeValueForKey:@&quot;isExecuting&quot;]; [self didChangeValueForKey:@&quot;isFinished&quot;]; // Set ranIt to YES to prevent the operation from // being passed to this method again in the future. ranIt = YES; } return ranIt; } 3.9.3 取消操作对象当将操作对象添加到操作队列里面的时候，一个操作对象的管理就交给了操作队列，也不能被移除了，唯一使操作对象出列的方法就是调用它的cancel函数，你也可以取消所有的操作对象，通过调用操作队列的cancelAllOperations 你可以在确保你不在需要操作对象的时候取消掉它。发出一个cancel命令，会将操作对象的关键路径变为canceled状态，这将阻止任务继续执行，由于canceled的操作对象也认为是完成的，那么依赖它的操作对象就可以移除依赖关系。然而，更多情况下，更常用的是取消所有操作独享，在某些重要的时候，比如应用退出、或者用户发出了取消指令，这比一个个取消要好很多。 3.9.4 等待操作对象的完成为了获取最佳的性能，你应该尽可能的让操作对象并发执行，让系统去干更多的事情，在你执行操作对象任务的时候，如果创建一个操作对象的时候，同时希望获得了操作对象的结果，你可以使用waitUntilFinished：方法来阻塞代码继续执行，直到这个操作对象执行完成。通常来讲，这是最好的方式去避免你能帮到它的时候，阻塞当前线程也许是一个比较好的解决方法。但这也带来了更多的同步性，而限制了整体的可并发性。 你绝不允许在主线程中调用这个方法，你最好在子线程或者其他的线程操作中这么做，阻塞主线程将会降低程序的可响应性。 除了等待一个任务完成，你可以等待一个操作队列所有的任务执行完成，通过调用waitUntilAllOperationsAreFinished，当你等待一个操作队列任务完成的时候，避免在别的线程中添加任务给它，以防延长等待时间。 3.9.5 挂起和恢复操作队列如果你想中途终止一个操作队列的话，你可以挂起相应的操作队列，使用setSuspended方法，挂起一个操作队列并不会导致正在执行的操作任务终止。它只是会阻止别的操作对象（操作队列中的）不去执行，你可能会在用户想暂停任务的时候挂起所有操作，因为用户还期望在某个时候恢复这些任务。","link":"/2016/08/27/%5B%E8%AF%91%5D%20ios%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"},{"title":"iOS接入fastlane简易版教程","text":"fastlane 是什么？一套使用Ruby写的自动化工具集，旨在简化Android和iOS的部署过程，自动化你的工作流。它可以简化一些乏味、单调、重复的工作，像截图、代码签名以及发布App fastlane 可以干什么 插件 功能 gym 是fastlane提供的打包工具。 snapshot 生成多个设备的截图文件 frameit 对截图加一层物理边框 increment_build_number 自增build number 然后与之对应的get_build_number。Version number同理。 cert： 创建一个新的代码签名证书 sigh： 生成一个provisioning profile并保存打当前文件 pem： 确保当前的推送证书是活跃的，如果没有会帮你生成一个新的 match： 在团队中同步证书和描述文件。(这是一种全新的管理证书的方式) testflight： 上传ipa到testflight deliver： 上传ipa到AppStore fastlane 安装指南gem 安装fastlane 1sudo gem install fastlane 新项目安装fastlane1fastlane init fastlane打包打包需要条件 条件 名称 是否必须 工程名 DailyClock 是 包名 打卡 是 打包环境 Debug 是 teamID M99LZTCK8N 是 provisioningProfiles {“com.chengyan.DailyClock” =&gt; “DailyClockAppStore”} 是 以下是上传蒲公英需要的参数 蒲公英的appid **** 否 蒲公英的userkey ** 否 以下是上传appstore需要准备的参数 用户名 xxxxxx@xx.com 是 密码 xxxxx 是 FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD xxxx 是 FASTLANE_SESSION xxx 是 可能遇到的问题 怎么获取 FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD？访问苹果账号管理添加app专用的密码 怎么获取FASTLANE_SESSION？命令行执行如下命令：fastlane spaceauth -u yourappleid command timed out after 10 seconds on try 1 of 4原因： 很大可能是机器不给力了，使xcodebuild -showBuildSettings ? -workspace ./XX.xcworkspace -scheme XX -configuration Release命令执行超时解决方法: 在Fastfile的 before_all方法中，添加 : 12ENV[&quot;FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT&quot;] = &quot;120&quot;ENV[&quot;FASTLANE_XCODEBUILD_SETTINGS_RETRIES&quot;] = &quot;4&quot; 一些范例 范例一、打包app并上传到蒲公英平台 123456789101112131415161718192021222324252627 desc &quot;Description of what the lane does&quot; lane :dk doipa_dir = &quot;fastlane_build/&quot;ipa_name = &quot;打卡&quot;+Time.new.strftime('%Y-%m-%d_%H:%M')archive_path = &quot;./build/ipa/tem/archive/DailyClock.xcarchive&quot;increment_build_number(xcodeproj:&quot;DailyClock.xcodeproj&quot;)build_app(workspace:&quot;DailyClock.xcworkspace&quot;,scheme:&quot;DailyClock&quot;,configuration:&quot;Debug&quot;,clean: true,output_directory:ipa_dir,archive_path:archive_path,export_options:{method:&quot;development&quot;, destination: &quot;export&quot;, stripSwiftSymbols: true, teamID: &quot;M99LZTCK8N&quot;, uploadBitcode: false, uploadSymbols: true, provisioningProfiles: {&quot;com.chengyan.DailyClock&quot; =&gt; &quot;DailyClockDev&quot;}}) # 发布到蒲公英平台 pgyer(api_key:&quot;替换为你的蒲公英平台的appkey&quot;,user_key:&quot;替换为你自己的userkey&quot;) end 范例二、打包app上传到appstore 123456789101112131415161718192021222324252627282930313233desc &quot;app store&quot; lane:release do ENV[&quot;FASTLANE_USER&quot;] = &quot;your appleid&quot; ENV[&quot;FASTLANE_PASSWORD&quot;] = &quot;password&quot; ENV[&quot;FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD&quot;] = &quot;yourpasssword&quot; ENV[&quot;FASTLANE_SESSION&quot;] = '''yoursession''' ipa_dir = &quot;fastlane_build/&quot; ipa_name = &quot;测一测&quot;+Time.new.strftime('%Y-%m-%d_%H:%M') archive_path = &quot;./build/ipa/tem/archive/xxx.xcarchive&quot; increment_build_number(xcodeproj:&quot;xxx.xcodeproj&quot;) build_app(workspace:&quot;xxx.xcworkspace&quot;, scheme:&quot;xxx&quot;, configuration:&quot;Release&quot;, clean: true, output_directory:ipa_dir, archive_path:archive_path, export_options:{ method:&quot;app-store&quot;, destination: &quot;export&quot;, stripSwiftSymbols: true, teamID: &quot;xxx&quot;, uploadBitcode: false, uploadSymbols: true, provisioningProfiles: {&quot;xxxx&quot;} } ) upload_to_testflight( ipa: ipa_dir+'/grh.ipa', skip_waiting_for_build_processing: true )end 成功截图 命令执行12fastlane release # 打包并发布appstorefastlane dk #打包并发布到蒲公英 更多结合alfred效率神器，打包将更香。最终效果真香！！！","link":"/2022/07/28/iOS%E6%8E%A5%E5%85%A5fastlane%E7%AE%80%E6%98%93%E7%89%88%E6%95%99%E7%A8%8B/"},{"title":"iOS配置统一推送证书Token Authenticatio方式","text":"背景 由于开发者账号下面配置的app越来越多，对于推送证书的配置有了新的要求，证书尽可能只需要配置一次就可以。 方案Apple提供了一种新的方案，在开发者网站上，可以创建keys，极光推送目前也已经对这种方式进行了支持，创建好的key，保存到本地会是一个p8类型的文件，创建流程如下123 第一步: 点击key盘边的“+”号按钮 图一 第二步：然后勾选apple push notification service 图二 第三步：输入要创建的keys名称，然后点击右侧的regiest按钮 图三 第四部：登入极光平台，然后选中刚才生成的P8文件，之后，挨个填入对应的信息 图四 备注 极光推送网站 apple配置地址","link":"/2022/07/26/iOS%E9%85%8D%E7%BD%AE%E7%BB%9F%E4%B8%80%E6%8E%A8%E9%80%81%E8%AF%81%E4%B9%A6Token-Authenticatio%E6%96%B9%E5%BC%8F/"},{"title":"ios底层原理：OC对象","text":"一、OC对象的本质oc的对象占多大内存空间？ 答案是16个字节，为什么是16个，一个oc对象内部只存放了一个isa指针，而在64位系统中，一个指针占据的空间是8字节，但是为了字节对齐，最小的内存空间分配为16个字节。 oc的对象，是由类创建的，类在oc里面是Class，那么Class的本质是什么？实际上class是由c的结构体构成的。**参阅runtime中的objc.h文件可知,**具体实现如下 12345678910111213141516struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif} OBJC2_UNAVAILABLE; 每一个oc对象里面都有一个isa指针。如下 123 struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY;}; 二、对象的成员变量oc对象的成员变量，方法，协议统统都是存放在class里面。在上面的objc_class结构体中，很明显可以看到这一点。 三、也来聊聊isa上一张大神图 记住一点： 对象的isa指向的是：由谁创建的当前对象。 NSObject类的superclass 为nil NSObject元类的isa指向的是它自己 参考文章ios底层原理探究","link":"/2019/10/10/ios%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9AOC%E5%AF%B9%E8%B1%A1/"},{"title":"xcode自动打包实践","text":"1、问题背景公司是家小公司，没有成熟的打包系统，开发完app之后，往往需要开发人员用xcode打包，导出ipa文件，然后手动上传到蒲公英网站，然后把下载二维码发送给测试/老板。这里面有问题 占用开发人员的时间和设备。 不能保证每天都有可用的测试包，依赖开发人员打包。 重复工作,每天都要做，效率低下。 2 、解决方案可以利用脚本对xcode进行打包，然后发布上传到相应的平台。 这里面，核心的功能是xcodebuild，利用这个命令行工具，可以对工程进行打包，导出。流程图如下 3 、脚本文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#!/bin/shsource /etc/profile SECONDS=0now=$(date +&quot;%Y%m%d-%H:%M&quot;)setting_path=&quot;/Users/chengyan/Desktop/setting.plist&quot; # 项目名称project_name=$(/usr/libexec/PlistBuddy -c &quot;print project_name&quot; ${setting_path})echo $project_name# 项目路径project_path=$(/usr/libexec/PlistBuddy -c &quot;print project_path&quot; ${setting_path})echo $project_pathif [ -d &quot;${project_path}/${project_name}.xcworkspace&quot; ];then # workspace_path=&quot;${project_path}/${project_name}.xcworkspace&quot; workspace_path=&quot;${project_path}/${project_name}.xcworkspace&quot; echo $workspace_pathelse workspace_path=&quot;${project_path}/${project_name}.xcodeproj&quot; echo $workspace_pathfi# scheme名称scheme_name=$(/usr/libexec/PlistBuddy -c &quot;print scheme_name&quot; ${setting_path})# 项目版本version=$(/usr/libexec/PlistBuddy -c &quot;print version&quot; ${setting_path})# 开发者账号dev_account=$(/usr/libexec/PlistBuddy -c &quot;print dev_account&quot; ${setting_path})# 开发者密码dev_password=$(/usr/libexec/PlistBuddy -c &quot;print dev_password&quot; ${setting_path})# 配置打包方式configration=$(/usr/libexec/PlistBuddy -c &quot;print configration&quot; ${setting_path})# 发布地址 PGY 蒲公英 苹果商店 AppStoreupload_address=$(/usr/libexec/PlistBuddy -c &quot;print upload_address&quot; ${setting_path})# ipa包名称:项目名称+版本号+打包类型ipa_name=$(/usr/libexec/PlistBuddy -c &quot;print ipa_name&quot; ${setting_path})# ipa包路径ipa_path2=$(/usr/libexec/PlistBuddy -c &quot;print ipa_path&quot; ${setting_path})/${now}ipa_path=&quot;${ipa_path2}-V${version}-${upload_address}&quot;# 编译build路径archive_path=&quot;${ipa_path}/${project_name}.xcarchive&quot;echo ${archive_path}# 上传到蒲公英设置user_key=$(/usr/libexec/PlistBuddy -c &quot;print user_key&quot; ${setting_path})api_key=$(/usr/libexec/PlistBuddy -c &quot;print api_key&quot; ${setting_path})password=$(/usr/libexec/PlistBuddy -c &quot;print password&quot; ${setting_path})# 打包方式配置if [ ${upload_address} == 'AppStore' ]; then configration=&quot;Release&quot; plist_path=${project_path}/exportAppStore.plistelif [ ${upload_address} == 'PGY' ]; then if [ ${configration} == 'Release' ]; then plist_path=&quot;/Users/chengyan/Desktop/exportAdHot.plist&quot; else plist_path=exportDevelopment.plist fifiecho &quot;=======================正在清理工程=================&quot;xcodebuild clean -configuration ${configration} \\-workspace ${workspace_path} \\-scheme ${scheme_name} \\-quiet || exitecho '清理完成--------》》正在编译工程:'${configration}#通过wordspace方式打包if [ -d &quot;${project_path}/${project_name}.xcworkspace&quot; ]; then xcodebuild archive -workspace ${workspace_path} -scheme ${scheme_name} \\ -configuration ${configration} \\ -archivePath ${archive_path} -quiet || exitelse xcodebuild archive -project ${project_path} - scheme ${scheme_name}\\ -configuration ${configration} \\ -archivePath ${archive_path} -quiet || exitfi# 检查下是否构建成功if [ -d &quot;$archive_path&quot; ]; then echo '========项目构建成功========'else echo '========项目构建失败========' exit 1fiecho '编译完成---》》---开始ipa打包'xcodebuild -exportArchive -archivePath ${archive_path} \\-configuration ${configration} \\-exportPath ${ipa_path} \\-exportOptionsPlist ${plist_path} \\-quiet || exit# 检查下是否导出ipa包成功if [ -e &quot;${ipa_path}/${ipa_name}.ipa&quot; ]; then echo '========ipa 打包成功==========' open $ipa_pathelse echo '=========ipa 打包失败=========' exit 1fiecho '==========准备发布ipa包========='if [ ${upload_address} == &quot;AppStore&quot; ]; then echo '准备发布包到appstore'else echo '发布包到蒲公英平台' curl -F &quot;file=@${ipa_path}/${ipa_name}.ipa&quot; \\ -F &quot;uKey=${user_key}&quot; -F &quot;_api_key=${api_key}&quot; \\ -F &quot;password=${password}&quot; \\ https://www.pgyer.com/apiv1/app/upload if [ $? == 0 ]; then echo '=====提交蒲公英成功' else echo '=====提交蒲公英失败' fifi# 输出耗时echo &quot;执行时间:${SECONDS}秒&quot;exit 0 4、具体流程4.1、 在脚本的同级目录下，创建一个setting.json（名字不一定叫这个，可以自己随便起）文件这个文件主要用来配置脚本执行的环境、上传的平台、打完包存放ipa包的路径，如果是往appstore上传的话，还需要开发者的账号，密码等信息。 文件内容如下， 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;project_name&lt;/key&gt; &lt;string&gt;项目名称&lt;/string&gt; &lt;key&gt;project_path&lt;/key&gt; &lt;string&gt;/Users/chengyan/Desktop/工程文件目录&lt;/string&gt; &lt;key&gt;scheme_name&lt;/key&gt; &lt;string&gt;工程&lt;/string&gt; &lt;key&gt;version&lt;/key&gt; &lt;string&gt;1.6.5&lt;/string&gt; &lt;key&gt;upload_address&lt;/key&gt; &lt;string&gt;PGY&lt;/string&gt; &lt;key&gt;configration&lt;/key&gt; &lt;string&gt;Release&lt;/string&gt; &lt;key&gt;ipa_name&lt;/key&gt; &lt;string&gt;ipa包的名称&lt;/string&gt; &lt;key&gt;ipa_path&lt;/key&gt; &lt;string&gt;ipa包存放的地址&lt;/string&gt; &lt;key&gt;user_key&lt;/key&gt; &lt;string&gt;蒲公英平台userkey&lt;/string&gt; &lt;key&gt;api_key&lt;/key&gt; &lt;string&gt;蒲公英平台apikey&lt;/string&gt; &lt;key&gt;dev_account&lt;/key&gt; &lt;string&gt;苹果账号&lt;/string&gt; &lt;key&gt;dev_password&lt;/key&gt; &lt;string&gt;苹果账号密码&lt;/string&gt; &lt;key&gt;password&lt;/key&gt; &lt;string&gt;&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; 4.2、 导出ipa配置文件xcodebuild导出ipa包，核心命令 12345xcodebuild -exportArchive -archivePath ${archive_path} \\-configuration ${configration} \\-exportPath ${ipa_path} \\-exportOptionsPlist ${plist_path} \\-quiet || exit 导出ipad包的时候，需要一个ExportOption.plist文件，对应的参数为：exportOptionsPlist，这个文件用来对导出的包进行签名，配置是否要支持bitcode等信息。 如何获取这个文件？用xcode打一次包，之后在导出的文件夹下就会有这个文件。文件截图如下： 有了上面的两个文件之后，就可以通过运行脚本进行打包，然后把包上传到蒲公英/苹果商店了 5、 定时打包实现DailyBuild利用launchd命令行工具，定时执行脚本。 5.1、 创建一个”com.runSh.plist”json文件，用来配置启动任务，大致如下图 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;com.suoyi.service&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/Users/chengyan/Desktop/autoIpa.sh&lt;/string&gt; &lt;/array&gt; &lt;key&gt;StartCalendarInterval&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;Hour&lt;/key&gt; &lt;integer&gt;21&lt;/integer&gt; &lt;key&gt;Minute&lt;/key&gt; &lt;integer&gt;15&lt;/integer&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;Hour&lt;/key&gt; &lt;integer&gt;14&lt;/integer&gt; &lt;key&gt;Minute&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;key&gt;StandardErrorPath&lt;/key&gt; &lt;string&gt;/Users/chengyan/Desktop/TEST.err&lt;/string&gt; &lt;key&gt;StandardOutPath&lt;/key&gt; &lt;string&gt;/Users/chengyan/Desktop/TEST.out&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; 5.2、launchd 命令,主要用的就是load和unload命令1234567➜ ~ launchctl list // 获取所有定时任务➜ Desktop launchctl load com.suoyi.plist // 加载任务➜ Desktop launchctl list | grep com.suoyi.service // 查询当前任务的执行状态53241 0 com.suoyi.service➜ Desktop launchctl start com.suoyi.service // 开启任务➜ Desktop launchctl stop com.suoyi.service // 停止任务➜ Desktop launchctl unload com.suoyi.plist // 卸载任务 5.3、注意事项：需要将脚本文件的权限修改为777。修改命令如下1chmod 777 yourScrpt.sh 6、踩过的坑1号坑： 脚本文件不能放到中文文件夹下我用的是sublime2作为脚本开发工具，将脚本文件放在了我自己建的一个“脚本”文件夹下，结果编译的时候，一直报错。将脚本放到/Desktop之后，此问题解决 2号坑：路径一定要使用绝对路径如果手动执行脚本的话，使用相对路劲也是可以的。但是利用launchctl的方式启动定时任务，那么相对路径执行就会报路径找不到的错误 3号坑：脚本文件不能放到”.xcodeproj”目录曾经误以为是pod文件出错了，把锅摔给cocoapods（正好这段时间升级了cocoapod 1.8.1）后来发现根本不是，是因为放到“.xcodeproj”这个目录下，xcode打包的时候，会报奇奇怪怪的错误。将脚本文件挪走之后，问题解决 4号坑：为什么使用launchd而不是crontab这两都是执行定时任务的，一开始我使用的是crontab，用这个的时候，掉进了坑中坑。 4.1号坑：crontab执行脚本需要配置环境变量12* * * * * /bin/sh test.sh ❌* * * * * ./etc/profile; /bin/sh test.sh ✅ 4.2号坑：crontab无法对launched.keychain解锁 获取不到打包证书由于这两问题，放弃crontab，而使用launchd 5号坑：sh代码不熟悉，if判断 没加空格，缩进等","link":"/2019/09/29/xcode%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E5%AE%9E%E8%B7%B5/"},{"title":"《CoreData》系列（一）","text":"《题外篇》 学习这个东西贵在日积月累，而且事情往往说起来容易，做起来难，我是一个资深dota玩家，从dota1到dota2，从大学到工作，从2008年到2015年。一直看2009的视频，经常吐槽09视频更新速度慢，但是细细想想，09能保持优酷更新401（最近查看）期视频。又有多少人能做的到。故而最近下了一个决定，每周五务必更新一篇技术博客，就看看自己能坚持多久。 《正文》1 概述本系列研究讨论的是iOS开发中的一种数据持久化技术－coredata。coredata、sqlite、fmdb的优缺点不是我要讨论的重点 这个系列的blog主要会研究讨论以下几点 1.快速搭建coredata环境，主要是连接数据库、创建数据库托管对象模型（NSManagerObject）、如何保存数据、查询数据？ 2.coredata升级以及数据迁移的三种方式。 3.coredata与viewcontroller的结合，通过NSFetchedResultController使用coredata数据。 4.导入默认数据和前后台context。 5.关系 2 环境搭建 2.1 导入《CoreData》的framework默认读者知道如何创建一个空白的项目，建立好空白项目之后，搜索coredata按图2-1操作，点击添加完成framework的引入。 2.2 创建Model完成上述第一步，意味着我们已经可以使用CoreData提供的接口API了，接下来就是如何使用的事儿了。创建一个CoreData文件夹，专门用来放CoreData引擎，创建好文件夹后，右键点击选择newfile，然后按照图2-2所示创建数据库模型文件，并将其命名为Model,然后点击Model,添加Entity（表\\Class）,添加Attribute（字段\\属性），到这一部，基本上就把Model，创建出来了。并且里面有了数据模型结构，接下来的问题就是，连接数据库，根据模型创建托管对象了 2.3 代码连接数据库好啦，前面只是开胃菜，真正的大餐马上就要来了，在吃大餐前，有一些名称需要说明下 1.NSManagedObjectContext - 托管对象上下文，用来干嘛的呢？望文生意，用来管理托管对象的，负责从数据库中获取对象、保存对象、删除对象等等操作。2.NSManagedObjectModel - 对象模型， 根据我们上面创建的数据模型，创建出托管对象模型，（类似于加工厂的概念，能够用来生产对象的模子）3.NSPersistentStoreCoordinator - 持久化存储协调器，包含数据库的名称、存储数据类型（Sqlite、Xml、内存）、位置等信息4.NSPersistentStore - 持久化存储区 另外再附一张图来说明这几者的依赖关系 由于CoreData管理数据的过程较为通用，个人觉的还是封装成一个管理对象较好，方便以后代码复用，这里创建一个CoreDataHelper的类，专门用来管理数据对象，该类的头文件如下 1234567891011#import &lt;Foundation/Foundation.h&gt; #import &lt;CoreData/CoreData.h&gt; @interface CoreDataHelper : NSObject @property (nonatomic, strong) NSManagedObjectContext *context;//托管对象上下文 @property (nonatomic, strong) NSManagedObjectModel *model;//托管对象模型 @property (nonatomic, strong) NSPersistentStoreCoordinator *coordinate;//持久化存储协调器 @property (nonatomic, strong) NSPersistentStore *store;//持久化存储区 - (id)init; //初始化 - (void)loadStore; //加载cordite - (void)setupCoreData; //设置cordite相关信息 - (void)saveContext; //保存context CoreDataHelp的实现文件如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#import &quot;CoreDataHelper.h&quot; static NSString *storeFileName = @&quot;demo.sqlite&quot;; //测试数据库 @implementation CoreDataHelper #pragma mark - PATHS - (NSString *)applicationDocumentDirectory { if (debug) { NSLog(@&quot;Running %@ '%@'&quot;,[self class],NSStringFromSelector(_cmd)); } NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); return [paths lastObject]; } - (NSURL *)applicationStoreDirectory { if (debug) { NSLog(@&quot;Running %@ '%@'&quot;,[self class],NSStringFromSelector(_cmd)); } NSURL *url = [[NSURL fileURLWithPath:[self applicationDocumentDirectory]] URLByAppendingPathComponent:@&quot;stores&quot;]; if (![[NSFileManager defaultManager]fileExistsAtPath:[url path]]) { NSError *error = nil; BOOL success = [[NSFileManager defaultManager]createDirectoryAtURL:url withIntermediateDirectories:YES attributes:nil error:&amp;error]; if (success) { if (debug) { NSLog(@&quot;success create directory!&quot;); } }else{ NSLog(@&quot;failed create directory!&quot;); } } return url; } - (NSURL *)storeUrl { NSURL *storeUrl = [[self applicationStoreDirectory]URLByAppendingPathComponent:storeFileName]; NSLog(@&quot;storeurl = %@&quot;,storeUrl); return storeUrl; } #pragma mark - SETUP - (id)init { if (self) { _model = [NSManagedObjectModel mergedModelFromBundles:nil]; _coordinate = [[NSPersistentStoreCoordinator alloc]initWithManagedObjectModel:_model]; _context = [[NSManagedObjectContext alloc]initWithConcurrencyType:NSMainQueueConcurrencyType]; [_context setMergePolicy:NSMergeByPropertyObjectTrumpMergePolicy]; [_context setPersistentStoreCoordinator:_coordinate]; _importContext = [[NSManagedObjectContext alloc]initWithConcurrencyType:NSPrivateQueueConcurrencyType]; [_importContext performBlock:^{ [_importContext setPersistentStoreCoordinator:_coordinate]; [_importContext setMergePolicy:NSMergeByPropertyObjectTrumpMergePolicy]; [_importContext setUndoManager:nil]; }]; } return self; } - (void)loadStore { if (debug) { NSLog(@&quot;Running %@ ,'%@'&quot;,[self class], NSStringFromSelector(_cmd)); } if (_store) { return; } NSError *error; //NSMigratePersistentStoresAutomaticallyOption coreData尝试将低版本的数据模型向高版本进行迁移 //NSInferMappingModelAutomaticallyOption coredata会自动创建迁移模型，会去自动尝试 NSDictionary *option = @{NSMigratePersistentStoresAutomaticallyOption:@(YES), NSInferMappingModelAutomaticallyOption:@(YES), NSSQLitePragmasOption:@{@&quot;journal_mode&quot;:@&quot;DELETE&quot;}}; _store = [_coordinate addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[self storeUrl] options:option error:&amp;error]; if (!_store) { if (debug) { NSLog(@&quot;failed load store,error = %@&quot;,error); abort(); } } else/**/{ NSLog(@&quot;successfully add store : %@&quot;,_store); } } - (void)setupCoreData { [self loadStore]; } - (void)saveContext { if ([_context hasChanges]) { NSError *error = nil; if ([_context save:&amp;error]) { NSLog(@&quot;context save successfully&quot;); }else{ NSLog(@&quot;failed save %@&quot;,error); } }else{ NSLog(@&quot;skipped context save , there is no changes&quot;); } } @end 2.4 最后附上查询和保存数据库的代码在AppDelegate.m文件里写一个方法，用来初始化CoreData数据库 123456789101112- (CoreDataHelper *)cdh { if (!_cdh) { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ _cdh = [CoreDataHelper new]; }); [_cdh setupCoreData]; } return _cdh; } 下面是插入数据，查询、保存数据的方法 12345678910111213141516171819- (void)demo { Item *bananer = [NSEntityDescription insertNewObjectForEntityForName:@&quot;Item&quot; inManagedObjectContext:[[self cdh] context]]; bananer.unit = kg; bananer.name = @&quot;bananer&quot;; Item *oranger = [NSEntityDescription insertNewObjectForEntityForName:@&quot;Item&quot; inManagedObjectContext:[[self cdh] context]]; oranger.unit = kg; oranger.name = @&quot;Oranger&quot;; NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@&quot;Item&quot;]; NSArray *result = [[[self cdh]context] executeFetchRequest:request error:nil]; for (Item *item in result) { if (debug) { NSLog(@&quot;item.name = %@&quot;,item.name); } } [[self cdh]saveContext]; } 2.5 小结经过这么一番下来，终于将CoreData技术应用到我们的项目中了，我们现在能做到，把数据插入到数据库、也能从数据库中读取出数据来，也能保存数据。但是要注意这才是刚刚开始，接下来还有更多的coredata问题等着我们，比方说下节要介绍的数据迁移问题。","link":"/2016/08/27/%E3%80%8ACoreData%E3%80%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"《CoreData》系列（二）","text":"CoreData数据迁移以及版本升级 1 概述 为什么要有数据迁移？由于CoreData可视化的特殊性，那么当数据模型发生变化时，相应的sqlite数据库的表由于不知道model发生了变化，表结构必须相应的做出调整，否则会导致程序Crash，CoreData的解决方案是通过创建新的sqlite表，然后将旧的数据迁移到新表上得方案来处理。下面分别介绍三种数据迁移的方式，并详细说明三种迁移方式的应用场景和注意事项。 1.轻量级的数据迁移方式2.默认的迁移方式3.使用迁移管理器 1.1 轻量级的数据迁移方式 轻量级的数据迁移，也就是说，并不需要程序员做很多事情就可以完成数据的迁移，是由系统默认进行的数据迁移。那么如何进行轻量级的数据迁移呢，当model的表字段发生变化，且应用程序已经发布过版本时，此时千万不能单单修改原model来达到修改model的目的，如果这样做的话，程序会crash。正确的做法是， 1.新建一个model，并将model命名为model2，并将model2设置为当前model。2.修改NSPersistentStoreCoordinator加载缓存区的配置。具体如下 123456789NSDictionary *option = @{NSMigratePersistentStoresAutomaticallyOption:@(YES), NSInferMappingModelAutomaticallyOption:@(YES), }; _store = [_coordinate addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[self storeUrl] options:option error:&amp;error]; tips：使用iCloud开发程序的app，只能使用这种迁移方式。 1.2 默认的迁移方式 正常情况下，使用轻量级的数据迁移已经足够了，但是如果由于开发需要，需要将某个Entity下面的某个Attribute迁移到新的Entity下的某个Attribute，那么轻量级的迁移方式就不能够满足需求，这个时候就需要使用默认的迁移方式来进行数据迁移。这里以一个例子代码来详细阐述如何进行默认的迁移 现在要将Model2里面的Measurement下面的name迁移到Account里面的下面的xyz属性下。1.根据model2来创建一个新model，并命名为model3，然后将model3设置为currentmodel。2.添加新的entity，并命名为Account，添加attribute xyz。3.删除model2里面的Measurement，根据model3创建NSManagerObect的子类Account。4.以model2为soureModel，model3为destinationModel添加一个MappingModel5.按照下图所示设置映射model即可6.最后记得将NSInferMappingModelAutomaticallyOption设置为Yes（coredata会优先读取映射model，如果没有就会自己推断），至此，默认的迁移方式就算是搞定了。 1.3 迁移管理器 简单概述下何为迁移管理器，迁移管理器，就是不再使用系统的NSPersistentCoordinator进行数据迁移，而是使用NSMigrationManager进行数据缓存区的迁移。并配合一个数据迁移视图控制器提供优雅的迁移等待界面。等待界面如下，是不是感觉很丑呢，哈哈。那么使用迁移管理器的好处又是什么呢？可以实现更加精细化的数据操作，此外还能向用户报告迁移进度。有这俩点，还不够我们去研究下它么?Let’s go! 准备工作 何时启用迁移管理器，即迁移的时机？ 迁移工作如何进行？ 迁移完成如何善后？ 下面对上面的问题一一来做解答迁移的时机，迁移工作需要在载入数据库的时候进行，即上节所讲的 loadStore：的时候进行，但是呢？还需要做一些判断工作。具体代码如下 123456789101112131415161718192021222324252627282930313233343536373839- (void)loadStore { if (debug) { NSLog(@&quot;Running %@ ,'%@'&quot;,[self class], NSStringFromSelector(_cmd)); } if (_store) { return; } BOOL useMigrateManager = MigrationMode; if (useMigrateManager &amp;&amp; [self isMigrationNecessaryForStore:[self storeUrl]]) { [self performBackgroundManagedMigrationForStore:[self storeUrl]]; }else{ NSError *error; //NSMigratePersistentStoresAutomaticallyOption coreData尝试将低版本的数据模型向高版本进行迁移 //NSInferMappingModelAutomaticallyOption coredata会自动创建迁移模型，会去自动尝试 NSDictionary *option = @{NSMigratePersistentStoresAutomaticallyOption:@(YES), NSInferMappingModelAutomaticallyOption:@(YES), NSSQLitePragmasOption:@{@&quot;journal_mode&quot;:@&quot;DELETE&quot;}}; _store = [_coordinate addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[self storeUrl] options:option error:&amp;error]; if (!_store) { if (debug) { NSLog(@&quot;failed load store,error = %@&quot;,error); abort(); } } else/**/{ NSLog(@&quot;successfully add store : %@&quot;,_store); } } } 其中有开关，用来控制是否使用迁移管理器，以及系统是否需要进行迁移的判断。系统是否需要迁移的判断代码如下 12345678910111213141516171819202122232425262728293031- (BOOL)isMigrationNecessaryForStore:(NSURL *)storeUrl { if (debug) { NSLog(@&quot;Running %@ '%@'&quot;,[self class],NSStringFromSelector(_cmd)); } //文件是否存在，如果不存在认为是用户设备上并没有持久化存储区，自然不需要迁移 if (![[NSFileManager defaultManager]fileExistsAtPath:[self storeUrl].path isDirectory:nil]) { if (debug) { NSLog(@&quot;Skipped Migration, source database missing&quot;); } return NO; } NSError *error = nil; NSDictionary *sourceMetaData = [NSPersistentStoreCoordinator metadataForPersistentStoreOfType:NSSQLiteStoreType URL:storeUrl error:&amp;error]; NSManagedObjectModel *destinationModel = _coordinate.managedObjectModel; //比较当前对象模型是否与用户之前安装的应用持久化存储区是否兼容。如果兼容，不需要迁移 if ([destinationModel isConfiguration:nil compatibleWithStoreMetadata:sourceMetaData]) { if (debug) { NSLog(@&quot;Skipped Migration, source database is already compatible&quot;); return NO; } } //所有情况都尝试了，发现还是需要进行数据迁移 return YES; } 迁移工作如何进行，众所周知，迁移工作是一项比较耗时间的工作，尤其是在数据库比较大的情况下，那么肯定不能放在前台进行,必须放在后台进行，前台展示加载进度，代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152- (void)performBackgroundManagedMigrationForStore:(NSURL *)store { if (debug) { NSLog(@&quot;Running %@ '%@'&quot;,[self class],NSStringFromSelector(_cmd)); } UIStoryboard *sb = [UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil]; self.migrationVC = [sb instantiateViewControllerWithIdentifier:@&quot;migration&quot;]; UIApplication *app = [UIApplication sharedApplication]; UINavigationController *navigationCtl = (UINavigationController *)[app keyWindow].rootViewController; [navigationCtl presentViewController:self.migrationVC animated:YES completion:nil]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^{ BOOL done = [self migrateStore:[self storeUrl]]; if (done) { dispatch_async(dispatch_get_main_queue(), ^{ NSError *error = nil; NSDictionary *configuration = @{NSMigratePersistentStoresAutomaticallyOption:@(YES), NSInferMappingModelAutomaticallyOption:@(YES), NSSQLitePragmasOption:@{@&quot;journal_mode&quot;:@&quot;DELETE&quot;}}; _store = [_coordinate addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[self storeUrl] options:configuration error:&amp;error]; if (_store) { if (debug) { NSLog(@&quot;success create store&quot;); } }else { if (debug) { NSLog(@&quot;failed, error = %@&quot;,error); } abort(); } [self.migrationVC dismissViewControllerAnimated:YES completion:nil]; self.migrationVC = nil; }); } }); } 接下来是，真正的迁移过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859- (BOOL)migrateStore:(NSURL *)store { if (debug) { NSLog(@&quot;Running %@ '%@'&quot;,[self class],NSStringFromSelector(_cmd)); } NSDictionary *sourceMeta = [NSPersistentStoreCoordinator metadataForPersistentStoreOfType:NSSQLiteStoreType URL:store error:nil]; NSManagedObjectModel *sourceModel = [NSManagedObjectModel mergedModelFromBundles:nil forStoreMetadata:sourceMeta]; NSManagedObjectModel *destinationModel = _model; NSMappingModel *mappingModel = [NSMappingModel mappingModelFromBundles:nil forSourceModel:sourceModel destinationModel:destinationModel]; if (mappingModel) { NSError *error = nil; NSMigrationManager *migrationManager = [[NSMigrationManager alloc]initWithSourceModel:sourceModel destinationModel:destinationModel]; [migrationManager addObserver:self forKeyPath:@&quot;migrationProgress&quot; options:NSKeyValueObservingOptionNew context:nil]; NSURL *destinationStore = [[self applicationStoreDirectory]URLByAppendingPathComponent:@&quot;temp.sqlite&quot;]; BOOL success = NO; success = [migrationManager migrateStoreFromURL:store type:NSSQLiteStoreType options:nil withMappingModel:mappingModel toDestinationURL:destinationStore destinationType:NSSQLiteStoreType destinationOptions:nil error:&amp;error]; if (success) { if (debug) { NSLog(@&quot;Migration Successfully!&quot;); } if ([self replaceStore:store withStore:destinationStore]) { [migrationManager removeObserver:self forKeyPath:@&quot;migrationProgress&quot; context:NULL]; [[NSNotificationCenter defaultCenter]postNotificationName:someThingChangedNotification object:nil]; } }else{ if (debug) { NSLog(@&quot;Migration Failed&quot;); } } }else{ if (debug) { NSLog(@&quot;Mapping model is NULL&quot;); } } return YES; } 最后附上俩个辅助方法，用来观察迁移过程和替换数据库的 1234567891011121314151617181920- (BOOL)replaceStore:(NSURL *)old withStore:(NSURL *)new { BOOL success = NO; NSError *error = nil; if ([[NSFileManager defaultManager]removeItemAtURL:old error:&amp;error]) { error = nil; if ([[NSFileManager defaultManager]moveItemAtURL:new toURL:old error:&amp;error]) { success = YES; }else { if (debug) { NSLog(@&quot;failed move new store to old&quot;); } } }else{ if (debug) { NSLog(@&quot;failed remove old store&quot;); } } return success; } 12345678910111213- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(voidvoid *)context { if ([keyPath isEqualToString:@&quot;migrationProgress&quot;]) { dispatch_async(dispatch_get_main_queue(), ^{ float progress = [[change objectForKey:NSKeyValueChangeNewKey]floatValue]; self.migrationVC.progressView.progress = progress; int percenttage = progress * 100; NSString *string = [NSString stringWithFormat:@&quot;Migration Progress %i%%&quot;,percenttage]; self.migrationVC.progressLabel.text = string; }); } } 至此，三种数据迁移的方式，都已叙述完毕。[2 小结]（#1）三种迁移方式，各有各的好处，轻量级的迁移可以配套icloud实现云端存储，默认的数据迁移，支持将属性级别的数据进行任意迁移。迁移管理器，可以管理文件存储路径，并能够报告迁移进度，我们在开发过程中，应该按照自己的需求合理选择迁移方式，下一小节结合NSFetchedResultController进行数据的实际应用。","link":"/2016/08/27/%E3%80%8ACoreData%E3%80%8B%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"使用钉钉机器人将禅道任务，自动发送到钉钉群组","text":"一、为什么要开发这样一个功能？ 禅道，是公司用来对项目进行管理的软件，主要是用来对项目任务、产品bug进行追踪和管理.钉钉，是公司所有员工用来工作沟通的软件 将禅道上面，每个员工工作任务的情况，进行汇总并同步到钉钉群，有助于项目人员及管理人员对项目执行情况快速及时的掌握 下图是最终实现的效果图，钉钉机器人将项目组成员，一周任务完成情况，进行汇总。未完成的任务点击链接可传送到禅道对应的任务页面，进行快速处理 二、实现原理 钉钉的webhook机制 禅道的二次开发API python脚本 crontab定时器 钉钉的webhook机制钉钉的webhook，是可以通过向一个url地址，发送消息，然后钉钉解析之后，会根据消息类型展示不同的样式卡片，而这个url，就是通常我们说的webhook，翻译成中文就是“网络钩子的意思” 添加一个钉钉群组机器人，大概需要以下四步第一步： 群组中进入群设置 第二步：点击智能助手，进入机器人设置页 第三步：勾选自定义机器人，并进入机器人设置页 第四步:机器人添加设置页 禅道的二级开发api想要实现我们的效果，需要拿到每个员工的任务列表，而拿到任务列表，需要获取每个员工的编号，禅道里面是用户名。通过用户名获取该用户的所有任务列表。 首先遇到的问题是，登录问题禅道是需要进行登录的，登录是要建立会话的，这里使用的session进行会话管理,但是并不是每一个登录用户都可以随意获取别人的任务状态，这里涉及到另外一个问题权限问题权限找田新亮，将账户提升为“admin开发者”。 至此禅道api的大体流程就出来了！ 获取禅道sid 拿到sid与admin开发者权限的账号进行登录 获取需要汇报任务的成员username 根据username去获取任务状态，任务状态分为：未开始、进行中、已完成 python脚python脚本主要是实现，上述所说的禅道获取任务列表，以及将消息发送到webhook的钉钉机器人，代码比较多，这里贴一部分核心代码，主要是禅道的登录与任务列表的获取禅道登录与任务列表获取核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Zentao_cli(object): session = None # 用于实现单例类，避免多次申请sessionID sid = None def __init__(self, url, account, password, override=False): self.url = url self.account = account # 账号 self.password = password # 密码 self.session_override = override # 是否覆盖原会话 self.pages = { &quot;sid&quot;: &quot;/api-getsessionid.json&quot;, # 获取sid的接口 &quot;login&quot;: &quot;/user-login.json?account={0}&amp;password={1}&amp;zentaosid={2}&quot;, # 登录的接口 &quot;get_story_list_by_projectID&quot;: &quot;/index.php?t=json&amp;m=story&amp;f=ajaxGetProjectStories&amp;projectID={0}&quot;, &quot;get_task_list_by_account&quot;: &quot;/task-ajaxGetUserTasks-{0}-1-{1}.json&quot;, # &quot;get_task_list_by_account&quot;: &quot;/user-view-chengyan.json&quot;, &quot;get_story_list_by_account&quot;: &quot;/index.php?&quot; } self.s = None self.sid = None def req(self, url): # 请求并返回结果 print(url) web = self.s.get(url) print(web.content) if web.status_code == 200: resp = json.loads(web.content) if resp.get(&quot;status&quot;) == &quot;success&quot;: return True, resp else: return False, resp def login(self): if self.s is None: if not self.session_override and Zentao_cli.session is not None: self.s = Zentao_cli.session self.sid = Zentao_cli.sid else: # 新建会话 self.s = requests.session() res, resp = self.req(self.url.rstrip(&quot;/&quot;) + self.pages[&quot;sid&quot;]) if res: print(&quot;获取sessionID成功&quot;) self.sid = json.loads(resp[&quot;data&quot;])[&quot;sessionID&quot;] Zentao_cli.sid = self.sid login_res, login_resp = self.req( self.url.rstrip(&quot;/&quot;) + self.pages[&quot;login&quot;].format(self.account, self.password, self.sid)) if login_res: print(&quot;登录成功&quot;) Zentao_cli.session = self.s crontab定时器作为一个机器人，肯定是需要自己去做一些事情，我们脚本开发完成之后，肯定不能再去浪费时间去手动操作了，那么在macos或linux系统里面，需要用到crontab 定时去执行我们的脚本，我这里设置的时间是每周六的下午5.30分，去定时跑一下脚本，然后就会发消息到钉钉群了crontab的写法比较简单，下面是我这次用到的写法 130 17 * * 6 /Users/chengyan/Desktop/quanqiuwa/zandaoPlugin/main.py&gt;&gt;/Users/chengyan/Desktop/quanqiuwa/zanDaoPlugin/zandaoPlugin.log 2&gt;&amp;1 三、后续计划与改进 @未完成任务小伙伴群组消息太多，可能会有小伙伴将群设置为勿扰模式，那么针对没有完成任务的小伙伴，当然很多时候，并不是真的没有完成任务，而是忘了修改禅道任务的状态，考虑添加一个功能是：有未完成任务的小伙伴，会去主动的@一下 禅道bug未解决情况汇总禅道还支持，获取未完成bug的列表拉去，这个目前不是很紧急，等项目不忙的时候，可以搞起来 四、小结做这个功能的出发点是利用自己所掌握的知识做一些效能提高方面的事情，总的来说还是希望在人工智能时代，将一些非人工的事情，让机器去做，节省人力成本，后续如果有希望帮助的小伙伴，可以随时钉钉联系我，一起为公司的发展、壮大添砖加瓦。","link":"/2020/12/15/%E4%BD%BF%E7%94%A8%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B0%86%E7%A6%85%E9%81%93%E4%BB%BB%E5%8A%A1%EF%BC%8C%E8%87%AA%E5%8A%A8%E5%8F%91%E9%80%81%E5%88%B0%E9%92%89%E9%92%89%E7%BE%A4%E7%BB%84/"},{"title":"修改Mac系统的命令行默认启动为Python3","text":"问题mac系统的默认python环境为2.7.10，当前python的主流库都升级到3.7版本了。因此需要对python进行升级.升级方法这里不在介绍，参考这里， 当将本机的python升级到3.7之后，在mac自带终端，输入python -V之后会发现版本仍然是之前的2.7.10 解决办法 打开命令行，执行如下命令 1➜ ~ open ~/.bash_profile 在该文件的最下面，添加如下命令 12export PATH=${PATH}:/Library/Frameworks/Python.framework/Versions/3.7/binalias python=&quot;/Library/Frameworks/Python.framework/Versions/3.7/bin/python3.7&quot; 最后执行 123➜ ~ source ~/.bash_profile➜ ~ python -VPython 3.7.4 但是这么解决还有一个问题，当重启命令行之后，又会变为2.7.10版本。接下来需要继续执行 1open /etc/bashrc 在该文件的最后面添加如下命令source ~/.bash_profile 123456789101112# System-wide .bashrc file for interactive bash(1) shells.if [ -z &quot;$PS1&quot; ]; then returnfiPS1='\\h:\\W \\u\\$ '# Make bash check its window size after a process completesshopt -s checkwinsize[ -r &quot;/etc/bashrc_$TERM_PROGRAM&quot; ] &amp;&amp; . &quot;/etc/bashrc_$TERM_PROGRAM&quot;source ~/.bash_profile 大部分时候，问题到这就解决了。但是如果使用了iTerm2,那么还需要打开 1open /etc/zshrc 在该文件的最后面添加source ~/.bash_profile 123456789# Correctly display UTF-8 with combining characters.if [ &quot;$TERM_PROGRAM&quot; = &quot;Apple_Terminal&quot; ]; then setopt combiningcharsfidisable log[ -r &quot;/etc/zshrc_$TERM_PROGRAM&quot; ] &amp;&amp; . &quot;/etc/zshrc_$TERM_PROGRAM&quot;source ~/.bash_profile 问题解决!","link":"/2019/10/30/%E4%BF%AE%E6%94%B9Mac%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E4%B8%BAPython3/"},{"title":"关于Runtime的一些理论和实践","text":"前言网上讲解Runtime的教程非常之多，有些讲的还算不错，有些感觉就是人云亦云，所以读者就应该好好甄别下学习的资料。我在本文的最后，会列出一些我认为讲的不错的参考资料，以供参考。接下来就进入正文 正文理论部分基础中的基础​ 假设看官有一定的数据结构知识，知道什么叫结构体，因为接下来我要讲述的这个东西就是从结构体开始的。如果有不懂的同学请走这里传送门 ​ iOS中Class的定义如下 1234567891011121314151617181920struct objc_class {//class 的结构体 Class isa OBJC_ISA_AVAILABILITY;//class的isa指向的是元类，元类的isa指向的是根元类。#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE;//父类指针 const char *name OBJC2_UNAVAILABLE;//类名称 long version OBJC2_UNAVAILABLE;//类版本 long info OBJC2_UNAVAILABLE;//信息 long instance_size OBJC2_UNAVAILABLE;//实例的大小 struct objc_ivar_list *ivars OBJC2_UNAVAILABLE;//成员变量列表 struct objc_method_list **methodLists OBJC2_UNAVAILABLE;//方法列表 struct objc_cache *cache OBJC2_UNAVAILABLE;//缓存方法 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;//协议列表#endif} OBJC2_UNAVAILABLE;typedef struct objc_class *Class;//此处定义了结构体指针Classtypedef struct objc_object { Class isa;} *id; //此处定义了结构体指针id，id内部有一个isa Class指针，指向它的类。 ​ isa指针是实例方法在运行时能够被执行的关键，运行时系统将依靠isa指针找到实例所在的类，进而找到方法列表和缓存方法，进行消息的发送。如果消息得不到执行，将根据类里面的super_classs指针找父类的实例方法。但是如果是类方法或者说是+号方法进行消息发送，那么将会获取类里面的isa指针进而找到元类，获取元类里面的方法列表或缓存方法进行消息处理，如果没找到，那么将去寻找元类里面的super_class指针找父元类的类方法。 ​ 下面是哥们从网上找的一张isa 和super_class指针的指向图 基础​ 有了基础中的基础之后，我们才知道Objective-C的本源其实也是来自于C语言，来自于结构体。那么有了这些之后，怎么让OC的类和对象在我们的程序内部运作起来，接下来，有个新的东西要登场了，那就是objc_msgSend，请记住它，正是有了它objective-c才真正称得上是一门面向运行时的语言。 ​ objc_msgSend实质上就是一个C函数。其次objc_msgSend的参数类型第一个必须是id，第二个是SEL，第三个是va_list参数列表。从cocoa的objc.h文件中，我们可以看到它的定义。 1id objc_msgSend(id self, SEL op, ...)//运行时消息发送的函数 ​ 当你以为这就是运行时发送消息的全部时，很不幸的告诉你，远远没有这么简单，objc_msgSend还有一大帮兄弟姐妹，它们如下 12345id objc_msgSendSuper(struct objc_super *super, SEL op, ...)//super 指针调用方法的发送的消息void objc_msgSend_stret(id self, SEL op, ...)//当返回值是结构体时，发送此消息void objc_msgSendSuper_stret(struct objc_super *super, SEL op, ...)//super指针调用，返回值是结构体时，发送此消息double objc_msgSend_fpret(id self, SEL op, ...)//返回值为float类型，发送此消息(i386)long double objc_msgSend_fpret(id self, SEL op, ...)//返回值为为float类型，发送此消息(x86_64) ​ 其实，这些并不重要，只要掌握objc_msgSend这个就可以了，上面的这些兄弟姐妹只需要了解下就行。 消息发送​ 当[obj message]调用时，将会被转化为((void (*)(id,@sel(message))objc_msgSend)(id,@sel(message))。此消息将走如下几个流程 检查接收的对象是否为nil，如果是，调用nil处理方案 在objc_object结构体中含有cache，首先会在Class的cache中查找IMP(如果没有缓存则会初始化缓存)，如果找到就会跳转到对应的函数上执行。 如果没有找到就像父类的Class查找，如果还没有没找到就继续向上查找，直到找到根类。 如果找到根类还是没有实现方案，这个时候就需要使用_objc_msgForward函数指针替代imp，最后来执行这个imp（动态方法实现）。 消息转发1234+ (BOOL)resolveInstanceMethod:(SEL)aSEL //动态解析方法，给处理不了的sel动态加IMP实现- (id)forwardingTargetForSelector:(SEL)aSelector//没有方法？那就看看谁能实现这个方法，让谁去执行下- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector//还是没谁能执行？那就给这个方法重新签名- (void)forwardInvocation:(NSInvocation *)anInvocation//重新签名的方法，可以试着让转发下 ​ 理论部分到此告一段落，接下里用实践的方式，来深入的理解下这套东西 实践部分解归档对象我们知道oc的对象如果确认了NSCoding协议的话，可以将对象归档为NSData，进而存储在文件中，方便下次使用，通常的做法是将一个对象的属性一个一个的按照类型进行encode，如int型的变量，采用encodeInt:forKey,bool 型的变量，采用encodeBool:forKey。有没有一种方法不管是任何对象都可以进行归档。而不需要我们手动去辨别对象类型，进而调用相应的归档方法呢，runtime的存在对解决这类问题提供了可能。下面以归档一个CYArchieve对象为例，进行阐释。 首先第一步，获取当前对象的成员变量个数。 12unsigned int count;Ivar *ivar = class_copyIvarList([self class], &amp;count); 此处调用了一个class_copyIvarList()方法，查询runtime，知道这个方法的作用如下 123// 根据已知的类，获取它的变量列表，outcount是这个变量列表的长度。如果一个类是nil或者没有变量列表，那么将返回NULL，且outCount将为0.注意该对象使用完之后，记得必须要free()!!!OBJC_EXPORT Ivar *class_copyIvarList(Class cls, unsigned int *outCount) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0); 调用这个方法之后，也就是说，可以获取到当前类的所有变量，和变量个数 第二步，解析Ivar，获取变量名称 这里还有一个Ivar，这是什么东西？查看其定义知道，这是一个不透明的结构体指针，封装了变量类型。ø 123456789101112/// An opaque type that represents an instance variable.typedef struct objc_ivar *Ivar;struct objc_ivar { char *ivar_name //变量名字 OBJC2_UNAVAILABLE; char *ivar_type //变量类型 OBJC2_UNAVAILABLE; int ivar_offset //变量在对象中的偏移量 OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif} 它有什么用呢？再来查找资料，苹果runtime现在已经开源，大可去其源码中找答案。 翻翻翻，翻到runtime的定义中，找到了它的用途。Ivar有很多用途，这里我们使用到的有下面俩个 123456// 根据获取到的Ivar结构体，获取它的名字OBJC_EXPORT const char *ivar_getName(Ivar v) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0);// 根据获取到的Ivar结构体，获取它的类型OBJC_EXPORT const char *ivar_getTypeEncoding(Ivar v) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0); 这俩个方法，可以帮助我们拿到当前变量的名称和变量的类型。名称，我们知道是变量的名称。如_name _title，之类的，可是类型是什么呢？还是得靠查苹果资料，我们找到了官方定义下图是部分定义 第三步，进行归档 现在有了变量名称和变量类型，我们基本就可以对对象的变量进行归档了。 头文件如下定义 1234567@interface CYArchieve : NSObject@property (nonatomic, copy) NSString *userName;@property (nonatomic, assign) const void * token;@property (nonatomic, assign) int length;@property (nonatomic, strong) NSNumber *age;@property (nonatomic, assign) float height;@end 对此对象进行归档 具体代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- (void)encodeWithCoder:(NSCoder *)aCoder{ unsigned int count; Ivar *ivar = class_copyIvarList([self class], &amp;count); for (unsigned int i = 0; i &lt; count; i++) { Ivar iva = ivar[i]; // 成员变量名 const void* name = ivar_getName(iva); NSString *ivarName = [NSString stringWithUTF8String:name]; ivarName = [ivarName substringFromIndex:1]; // 获取get方法 SEL getter = NSSelectorFromString(ivarName); // 能响应getter方法 if ([self respondsToSelector:getter]) { const void *typeEncoding = ivar_getTypeEncoding(iva);//获取变量类型 NSString *type = [NSString stringWithUTF8String:typeEncoding];//将c字符串转变为oc字符串 NSLog(@&quot;type = %@&quot;,type); // const void * if ([type isEqualToString:@&quot;r^v&quot;]) { const void * valueUTF8 = ((const void *(*)(id ,SEL))(void *)objc_msgSend)((id)self,getter); NSString *value = [NSString stringWithUTF8String:valueUTF8]; [aCoder encodeObject:value forKey:ivarName]; continue; } else if ([type isEqualToString:@&quot;f&quot;]){ float fvalue = ((float(*)(id,SEL))(void *)objc_msgSend)((id)self, getter); [aCoder encodeObject:@(fvalue) forKey:ivarName]; continue; } else if ([type isEqualToString:@&quot;i&quot;]){ int ivalue = ((int (*)(id, SEL))(void *)objc_msgSend)((id)self,getter); [aCoder encodeObject:@(ivalue) forKey:ivarName]; continue; } id obj = ((id(*)(id, SEL))(void *)objc_msgSend)((id)self,getter);//如果是OC类型的对象，这么获取 if (obj &amp;&amp; [obj respondsToSelector:@selector(encodeWithCoder:)]) {//判断是否有返回值 [aCoder encodeObject:obj forKey:ivarName];//之后进行编码 } /*//////////////////////////////////////////////////////////////////////////*/ /* 将(void*)指针强制转为返回值为float类型，参数为id，sel的函数指针。 ((float(*)(id,SEL))(void *)objc_msgSend)((id)self, getter); */ /*//////////////////////////////////////////////////////////////////////////*/ } } free(ivar);} 解档和归档类似，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162- (id)initWithCoder:(NSCoder *)aDecoder{ self = [super init]; if (self) { unsigned int count; Ivar *ivars = class_copyIvarList([self class], &amp;count); for (unsigned int i = 0; i &lt; count; i++) { Ivar ivar = ivars[i]; const void * ivarName = ivar_getName(ivar); NSString *ivarString = [NSString stringWithUTF8String:ivarName]; ivarString = [ivarString substringFromIndex:1]; NSString *setter = ivarString; if (![setter hasPrefix:@&quot;_&quot;]) { char firstLatter = [setter characterAtIndex:0]; NSString *firstLetterString = [NSString stringWithFormat:@&quot;%c&quot;,firstLatter]; setter = [setter substringFromIndex:1]; setter = [NSString stringWithFormat:@&quot;%@%@&quot;,[firstLetterString uppercaseString] ,setter]; } setter = [NSString stringWithFormat:@&quot;set%@:&quot;,setter]; SEL Sel = NSSelectorFromString(setter); if ([self respondsToSelector:Sel]) { const void *typeUTF8 = ivar_getTypeEncoding(ivar); NSString *type = [NSString stringWithUTF8String:typeUTF8]; if ([type isEqualToString:@&quot;r^v&quot;]) { NSString *value = [aDecoder decodeObjectForKey:ivarString]; if (value) { ((void (*)(id,SEL,const void *))(void *)objc_msgSend)((id)self,Sel,value.UTF8String); } continue; } else if ([type isEqualToString:@&quot;i&quot;]){ NSNumber *number = [aDecoder decodeObjectForKey:ivarString]; int num = [number intValue]; ((void(*)(id ,SEL,int))(void *)objc_msgSend)((id)self,Sel,num); continue; } else if ([type isEqualToString:@&quot;f&quot;]){ NSNumber *number = [aDecoder decodeObjectForKey:ivarString]; float flo = [number floatValue]; ((void(*)(id ,SEL,float))(void *)objc_msgSend)((id)self,Sel,flo); continue; } id obj = [aDecoder decodeObjectForKey:ivarString]; if (obj) { ((void(*)(id, SEL, id))(void *)objc_msgSend)((id)self,Sel,obj); } } } free(ivars); } return self;} 消息转发这一小节，我来研究下runtime里面的消息转发机制，都知道，objc_msgsend()发送之后，如果目标不能执行相应的SEL，会进入到前文我们介绍的那四个方法中，具体的实践是怎么样的呢，这里我写个demo来演示下，一方面是自己学习，另一方面也做个笔记，方便以后查阅。 动态添加方法 首先创建了一个CYStudent类，然后在头文件声明了一个study方法 12345@interface CYStudent : NSObject- (void)study;@end 但是，我们在.m文件中不实现此方法，由此来验证，是否会进入消息转发流程，之后在.m文件中实现resolveInstanceMethod:此方法，如下 1234567891011121314void play(id obj,SEL sel){ NSLog(@&quot;这个学生不学习，只知道玩耍！&quot;);}@implementation CYStudent+ (BOOL)resolveInstanceMethod:(SEL)sel{ if([NSStringFromSelector(sel) isEqualToString:@&quot;study&quot;]){ return class_addMethod(self, sel, (IMP)play,&quot;v@:&quot;); } return [super resolveInstanceMethod:sel];}@end 经如下代码测试，发现确实进入了play函数，执行结果如下 1234CYStudent *laosan = [CYStudent new];[laosan study];2017-06-08 22:21:34.997 RuntimeDemo[1381:190411] 这个学生不学习，只知道玩耍！ 消息转发 这里以CYTeacher为例，依然是让CYTeacher执行study方法，但是不给其动态解析的机会，让其将消息发送给CYStudent，CYStudent将继续动态添加方法的流程，具体实现如下 123456789101112131415161718192021222324252627@interface CYTeacher : NSObject@end@implementation CYTeacher+ (BOOL)resolveInstanceMethod:(SEL)sel{ return NO;}- (id)forwardingTargetForSelector:(SEL)aSelector{ //如果转发的消息是play，老师执行不了，那就让学生对象执行下试试 if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;study&quot;]) { return [CYStudent new]; } return [super forwardingTargetForSelector:aSelector];}@end/*/////////////////////////////以下为测试代码///////////////////////////////*/ CYTeacher *teacher = [CYTeacher new]; [teacher performSelector:@selector(study) withObject:nil afterDelay:0]; /*/////////////////////////////以下为执行结果///////////////////////////////*/2017-06-08 22:31:23.541 RuntimeDemo[1457:215285] 这个学生不学习，只知道玩耍！ 方法签名 接下来研究下方法签名和方法调用的问题，以CYDoctor为例，此处还是让CYDoctor对象执行study方法，但是不实现resolveInstanceMethod: 和forwardingTargetForSelector:这俩个方法，而是让其进入方法签名里面，生成一个方法签名，之后再执行forwardInvocation:方法。以下是我做的测试代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@interface CYDoctor : NSObject@end@implementation CYDoctor+ (BOOL)resolveInstanceMethod:(SEL)sel{ return NO;}- (id)forwardingTargetForSelector:(SEL)aSelector{ return nil;}- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{ if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;study&quot;]) { return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; } return [super methodSignatureForSelector:aSelector];}- (void)forwardInvocation:(NSInvocation *)anInvocation{ [anInvocation setSelector:@selector(surgery:)]; [anInvocation setTarget:self]; [anInvocation invoke];}- (void)surgery:(id)sender{ NSLog(@&quot;sender : %@&quot;,sender); NSLog(@&quot;手术中，请勿打扰!!!&quot;);}@end/*/////////////////////////////以下为测试代码///////////////////////////////*/ CYDoctor *doctor = [CYDoctor new]; [doctor performSelector:@selector(study) withObject:nil afterDelay:0]; /*/////////////////////////////以下为执行结果///////////////////////////////*/2017-06-08 22:45:39.442 RuntimeDemo[1544:239413] sender : (null)2017-06-08 22:45:39.442 RuntimeDemo[1544:239413] 手术中，请勿打扰!!! 经过这三个小例子，基本对objc_msgSend()的发送流程搞清楚了，接下里准备研究下MethodSwizzling MethodSwizzling以NSMutableArray为例，我们来替换系统的objectAtIndex：,insertObject:AtIndex:,removeObjectAtIndex:等方法。 首先我们给NSobject类添加一个category，用来给任何类进行methodSwizzling。并提供一个方法，用来交换原方法和替换方法。 12345678910111213141516171819202122232425262728#import &lt;objc/runtime.h&gt;@implementation NSObject (MethodSwizzling)+ (void)swizzlingOriginSelector:(SEL)originSel withSwizzledSelector:(SEL)swizzledSel{ Class class = [self class]; Method originMethod = class_getInstanceMethod(self, originSel); Method swizzledMethod = class_getInstanceMethod(self, swizzledSel); // 给系统的方法，添加一个swizzledSel的实现 BOOL didAddMethod = class_addMethod(class, originSel, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); // 原先的方法并不存在，所以添加成功了，那么替换swiizzledSel的实现为系统原来的实现 if (didAddMethod) { class_replaceMethod(class, swizzledSel, method_getImplementation(originMethod), method_getTypeEncoding(originMethod)); } else{ method_exchangeImplementations(originMethod, swizzledMethod); } } 这之后，我们创建一个NSMutableArray的category，用来执行运行时方法替换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#import &quot;NSMutableArray+MethodSwizzling.h&quot;#import &lt;objc/runtime.h&gt;#import &quot;NSObject+MethodSwizzling.h&quot;@implementation NSMutableArray (MethodSwizzling)+ (void)load{ static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ [self swizzlingOriginSelector:@selector(removeObject:) withSwizzledSelector:@selector(cy_removeObject:)]; Class __NSArray_M = NSClassFromString(@&quot;__NSArrayM&quot;); [__NSArray_M swizzlingOriginSelector:@selector(objectAtIndex:) withSwizzledSelector:@selector(cy_objectAtIndex:)]; [__NSArray_M swizzlingOriginSelector:@selector(addObject:) withSwizzledSelector:@selector(cy_addObject:)]; [__NSArray_M swizzlingOriginSelector:@selector(insertObject:atIndex:) withSwizzledSelector:@selector(cy_insertObject:atIndex:)]; [__NSArray_M swizzlingOriginSelector:@selector(removeObjectAtIndex:) withSwizzledSelector:@selector(cy_removeObjectAtIndex:)]; });}- (id)cy_objectAtIndex:(NSInteger)index{ NSInteger count = [self count]; if (count == 0) { NSLog(@&quot;array is empty&quot;); return nil; } if (index &gt;= count) { NSLog(@&quot;index is bigger than count&quot;); return nil; } else{ return [self cy_objectAtIndex:index]; }}- (void)cy_removeObject:(id)objec{ if (objec == nil) { NSLog(@&quot;%s called,object is nil ,so return&quot;,__FUNCTION__); return; } [self cy_removeObject:objec];}- (void)cy_addObject:(id)object{ if (object == nil) { NSLog(@&quot;%s objc cannot be nil&quot;,__FUNCTION__); return; } [self cy_addObject:object];}- (void)cy_insertObject:(id)anObject atIndex:(NSUInteger)index{ if (anObject == nil) { NSLog(@&quot;%s objc cannot be nil&quot;,__FUNCTION__); return; } if (index &gt; self.count) { NSLog(@&quot;%s index %lu cannot bigger than self.count&quot;,__FUNCTION__, (unsigned long)index); return; } [self cy_insertObject:anObject atIndex:index]; }- (void)cy_removeObjectAtIndex:(NSUInteger)index{ if (index &gt;= self.count) { NSLog(@&quot;%s index %lu cannot bigger than self.count&quot;,__FUNCTION__, (unsigned long)index); } [self cy_removeObjectAtIndex:index];}@end 接下来是一个例子代码，我们来验证下替换的成果。 12345678910111213id nilobjc = nil;NSMutableArray *testArray = [NSMutableArray array];[testArray addObject:@&quot;&quot;];id obj = testArray[19];[testArray insertObject:nilobjc atIndex:0];[testArray removeObject:nilobjc];[testArray addObject:nilobjc];[testArray removeObjectAtIndex:0]; 打印结果为 12342017-06-11 22:43:18.705 RuntimeDemo[38559:4195212] index is bigger than count2017-06-11 22:43:18.705 RuntimeDemo[38559:4195212] -[NSMutableArray(MethodSwizzling) cy_insertObject:atIndex:] objc cannot be nil2017-06-11 22:43:18.706 RuntimeDemo[38559:4195212] -[NSMutableArray(MethodSwizzling) cy_removeObject:] called,object is nil ,so return2017-06-11 22:43:18.706 RuntimeDemo[38559:4195212] -[NSMutableArray(MethodSwizzling) cy_addObject:] objc cannot be nil 小结runtime的学习是持续进行了，我这篇blog也仅仅是抛砖引玉，如何灵活的在项目中使用Runtime才是我们真正应该做的。切记不可为了使用某项技术，硬刚。这是不好滴。😆 参考资料1.Runtime 学习笔记(一) 2.Runtime 学习笔记(二) 3.理解 Objective-C Runtime 4.https://github.com/CoderJackyHuang","link":"/2017/05/23/%E5%85%B3%E4%BA%8ERuntime%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%AE%BA%E5%92%8C%E5%AE%9E%E8%B7%B5/"},{"title":"关于如何将私人Pod库发布到pod库的心得","text":"引子周末闲来无事，琢磨了下如何将git上的代码做成一个开源的库，然后供自己和别人在开发中使用。捣鼓了一个多小时终于是成功了,大家可以在命令行下输入，pod search CYKit ，就会搜索到我这个小demo了。 准备工作 github准备开源的工程地址，并且有Release的Tag。如我自己的开源地址为：https://github.com/TripleFireMan/CYKit.git,Tag为0.1. 注册一个pod trunk 的账号，用来将自己的库push到cocoaPod的master spec中，这样才会能被别人搜索到。注册方式为 命令行输入 pod trunk register ab36474XXX@126.com ‘your user name’ –description=’device name or something other’ 正文 在工程目录下创建Podspec文件，cd 到要做成开源库的项目根路径下，执行 pod spec create CYKit。该命令执行之后就会在工程目录下生成一个CYKit.podspec的文件。 编辑Podspec文件，刚生成的Podspec文件很多信息都是没有的，需要手动去编辑，打开该文件会看到如下信息 123456789101112131415161718192021222324252627282930Pod::Spec.new do |s| # ――― Spec Metadata ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # These will help people to find your library, and whilst it # can feel like a chore to fill in it's definitely to your advantage. The # summary should be tweet-length, and the description more in depth. # s.name = &quot;CYKit&quot; s.version = &quot;0.1&quot; s.summary = &quot;something useful for daily development&quot; s.homepage = &quot;https://github.com/TripleFireMan&quot; # s.screenshots = &quot;www.example.com/screenshots_1.gif&quot;, &quot;www.example.com/screenshots_2.gif&quot; s.license = &quot;MIT&quot; s.author = { &quot;chengyan&quot; =&gt; &quot;ab364743113@126.com&quot; } s.platform = :ios, &quot;7.0&quot; s.source = { :git =&gt; &quot;https://github.com/TripleFireMan/CYKit.git&quot;, :tag =&gt; &quot;0.1&quot; } s.source_files = &quot;CYKit&quot;, &quot;CYKit/**/*.{h,m}&quot; #s.resources = &quot;Resources/*.png&quot; s.framework = &quot;UIKit&quot; s.requires_arc = true # s.xcconfig = { &quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SDKROOT)/usr/include/libxml2&quot; } # s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot;end 校验当前的podspec文件是否可用，在pod文件的目录下，执行此命令 pod spec lint CYKit.podspec,如果通过校验，则会有下面的提示1234567localhost:CYKit chengyan$ pod spec lint CYKit.podspec -&gt; CYKit (0.1)Analyzed 1 podspec.CYKit.podspec passed validation 反之就会有错误提示。有错误就解决错误好了 发布到cocoapod仓库，还是在podspec所在的文件下，执行pod trunk push 命令。发布成功的话就有下面的提示了1234567891011121314151617181920212223242526272829localhost:CYKit chengyan$ pod trunk push[!] Found podspec `CYKit.podspec`Updating spec repo `master`CocoaPods 1.2.0 is available.To update use: `sudo gem install cocoapods`Until we reach version 1.0 the features of CocoaPods can and will change.We strongly recommend that you use the latest version at all times.For more information, see https://blog.cocoapods.org and the CHANGELOG for this version at https://github.com/CocoaPods/CocoaPods/releases/tag/1.2.0Validating podspec -&gt; CYKit (0.1.5)Updating spec repo `master`CocoaPods 1.2.0 is available.To update use: `sudo gem install cocoapods`Until we reach version 1.0 the features of CocoaPods can and will change.We strongly recommend that you use the latest version at all times.For more information, see https://blog.cocoapods.org and the CHANGELOG for this version at https://github.com/CocoaPods/CocoaPods/releases/tag/1.2.0 - Data URL: https://raw.githubusercontent.com/CocoaPods/Specs/279e29a1cb259157cb329f9bbc2470a167667ee3/Specs/8/a/e/CYKit/0.1.5/CYKit.podspec.json - Log messages: - February 19th, 04:07: Push for `CYKit 0.1.5' initiated. - February 19th, 04:07: Push for `CYKit 0.1.5' has been pushed (0.86529383 s). 小结通过上述简单几步操作，我们就发布了一个开源的cocoapod版本了，以后有需要就可以往上面添加代码了，解决了重复造轮子的问题。","link":"/2017/02/19/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%B0%86%E7%A7%81%E4%BA%BAPod%E5%BA%93%E5%8F%91%E5%B8%83%E5%88%B0pod%E5%BA%93%E7%9A%84%E5%BF%83%E5%BE%97/"},{"title":"如何使用subline-text2-作为markdown的编辑工具","text":"今年8月份的时候，在二代的带领下，接触了Hexo+Github搭建个人的博客空间的新姿势，在此基础上。我个人选择了sublinetext2 作为markdown的编辑工具，实测还可以，采用subline能够做到 在线预览 (通过安装OmniMarkupPreviewer实现) 语法高亮 (通过安装MarkdownEditing实现) 单纯的subline虽然也可以打开markdown文件，也可以编辑，但是效果和体验总是不太好，我今天介绍的这俩个插件能够大大提高书写效率和提升书写体验。先附俩张图体验一下最终的效果。 基本可以实现，在写的过程中就可以看到最终显示在网页上是什么效果。不用等写完之后再去调整展示的界面，还是挺方便的。 这里有几个点需要注意一下。 将OmniMarkupPreviewer，MarkdownEditing从github上clone到subline的packages下需要重启下subline。 如果是代码的话，高亮需要使```将代码包起来 ，形如```objc 这里添写需要写的代码``` 在线预览功能，可以通过在subline右键点击preview markdown on browser，也可以通过快捷键command + Alt + O 在线预览。 好久没有写东西了，写了这么点东西居然写了改，改了写，以后还是要常写常更，争取回到每周一更的正确轨道上来。","link":"/2016/12/29/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8subline-text2-%E4%BD%9C%E4%B8%BAmarkdown%E7%9A%84%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7/"},{"title":"如何在iOS9系统中使用Universal Link","text":"概述​ 在ios9系统中，可以通过类似打开网页的方式，通过http协议打开app。通过一个唯一的网址，可以指到app内部的一个特定的view。而不用再使用scheme。设想一下，如果twitter使用了Universal Link，如果你点击了一个twitter的链接。你的设备直接打开twitter app内相应的页面。而不是打开一个普通的网页，然后再通过这个网页打开twitter，这种体验将是非常平滑，且对用户来讲，也节省了很多不必要的操作。 功能​ 使用Universal Link 能让你的App做到，通过点击一个网址，打开你的app，并跳转到对应的页面。 准备工作​ 实现Universal link 并不难，但是你必须遵从一些条件。下面是需要准备的清单。 序号 条件 e.g. 1 注册域名 www.domian.com 2 可以SSL访问你的域名 支持SSL方式进行文件访问 3 能够上传一个Json文件到你的域名 apple-app-site-association 4 系统版本 ios9+ 5 开发环境 Xcode7+ ​ 如果你已经具备了上面所有的先决条件，那么接下来只需要3步就可以在IOS9上的设备实现Universal link。 具体步骤 添加域名到Capabilities 首先需要在xcode的capability下面添加域名，且必须得是applinks:的前缀，如果有二级域名，也一并加入进去，诸如(www.domain.com,news.domain.com,etc)![img](如何在iOS9系统中使用Universal-Link/apple_capabilities.png) 这将会使你的app访问一个特殊的json文件**”apple-app-site-association”**,当你首次运行app的时候，它就会从https://domain.com/apple-app-site-association 下载这个json文件。接下来，看步骤2来学习下怎么构造这个文件。 此外，还需要在网站上配置app的授权，允许universal link。编辑Associate Domain的授权为enable 上传apple-app-site-assosiation 文件 这个文件必须存在，且能通过SSL的方式，通过get请求获取到。你可以打开一个文本编辑器，然后写下如下的json格式 1234567891011{ &quot;applinks&quot;: { &quot;apps&quot;: [], &quot;details&quot;: [ { &quot;appID&quot;: &quot;TBEJCS6FFP.com.domain.App&quot;, &quot;paths&quot;:[ &quot;*&quot; ] } ] }} 在这个path 字段下，你可以有一个列表，这个列表是app允许反射到的url地址，或者也可以是一个*号，来标示你只是想打开一个app，而不管它的具体地址。 另外，你可能会好奇**”TBEJCS6FFP.com.domain.App“** 这个值是从哪获取的，通常来讲，它就是你app的bundleid所在的teamed。你也可以点击它来查询你的teamid,然后bundleid可以在app的General下查询到。 最后，如果你可以在你的根域名下，找到 https://domain.com/apple-app-site-association，那么你就可以开始下一步了。 在你的app内部如何处理universallink ​ 为了在app内部支持universal link，你需要在appdelegate中实现以下方法，application(_:continueUserActivity:restorationHandler:) ，尽管这个方法可能会处理多个事件（如 Handoff，SearchApi），但是我们只关注来自universal link的事件。 ​ 如果userActivity给的参数是NSUserActivityTypeBrowsingWeb.这就意味着它是来自universal link的参数，在这个情况下，首先保证它的webpageURL不为空，这个属性指的就是用户打开的链接。那么它有可能为如下的格式http://domain.com/path/to/thezoo ​ 为了确保你的app能够转换这些URL，你需要做以下几步 通过NSURLComponents类解析webpageURL host以及path路径。 确保你能够识别这个host 尽量把path的路径对应到你的app页面中 确保path对应的页面能够展示 展示对应的页面给用户 如果上面的步骤失败了，苹果建议你的app，优雅的打开safari对应的网址。 其他当无法往根域名下放置apple-app-site-association文件的时候，可以考虑在二级域名下放置，同时将二级域名重定向到根域名。通过这种方式也可以实现苹果启动设备的时候获取文件。 使用二级域名重定向的时候，要对apple-app-site-association文件进行加密。 而且此文件的类型应该是application/pkcs7-mime 常见错误1234 ### Denying redirect 'https://www.domain.com/.well-known/apple-app-site-association' -&gt; 'http://err.taobao.com/error1.html'May 17 12:11:05 chengde-iPhone swcd(CoreUtils)[159] &lt;Notice&gt;: ### Rejecting URL 'https://www.domain.com/apple-app-site-association' for auth method 'NSURLAuthenticationMethodServerTrust': -6754/0xFFFFE59E kAuthenticationErr https://forums.developer.apple.com/thread/67882 http://stackoverflow.com/questions/34166173/apple-app-site-association-file-wont-download(解决方法) https://gist.github.com/anhar/6d50c023f442fb2437e1#sign-the-apple-app-association-file-using-openssl（服务端和客户端需要做的事） https://forum.ind.ie/t/ios-9-universal-links-apple-app-site-association-blues/986（一些注意事项） 检测工具https://search.developer.apple.com/appsearch-validation-tool/ https://limitless-sierra-4673.herokuapp.com/ 总结​ 最后用一张图来总结下这个流程,此外你也可以参考下苹果的文档，以备苹果更新 ​","link":"/2017/06/01/%E5%A6%82%E4%BD%95%E5%9C%A8iOS9%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8Universal-Link/"},{"title":"","text":"技术交流大纲交流背景入职一个多月，通过阅读公司的技术资料，结合自己多年的开发经验，分享一些好的，对项目有益的想法及落地方案，此外对项目的理解，提一些个人的看法，有什么不足/不对的地方，希望各位同事查漏补缺 关于调试工具DoraemonKit 目前在建龙物流端，接入了Dokit，此外根据 官方文档设计了两个插件， 一个是用来切换正式和测试环境， 一个是根据页面classname来跳转对于空页面（用于调试UI） 接入说明:插件的接入主要分下面几步，第一步： 创建一个插件Vc，用来承载插件功能,具体开发功能，用户自定义第二步： 实例化一个插件类，实现协议DoraemonPluginProtocol 1234// 该代理方法是点击插件按钮时会触发- (void) pluginDidLoad{ /// 如创建页面，push到堆栈中} 第三步：将插件挂载到dokit的首页上 1[[DoraemonManager shareInstance] addPluginWithTitle:@&quot;环境切换&quot; icon:@&quot;doraemon_default&quot; desc:@&quot;用于app内部环境切换功能&quot; pluginName:@&quot;KCEnvPlugin&quot; atModule:@&quot;业务专区&quot;]; 插件的目录结构如下，有兴趣的同事可以去看一下 1234567891011121314└── KCLogistics └── KCModules └── KCDebugModule └── Module ├── KCDebugModule.h ├── KCDebugModule.m ├── KCDebugVCJumpPlugin.h ├── KCDebugVCJumpPlugin.m ├── KCDebugVcJumpVC.h ├── KCDebugVcJumpVC.m ├── KCEnvChangeVC.h ├── KCEnvChangeVC.m ├── KCEnvPlugin.h └── KCEnvPlugin.m 关于项目组件化组件化的必要性，项目目前分为快成物流、快成司机、建龙司机、建龙物流、晋能物流、晋能司机。项目的管理主要靠创建不同的代码仓以及分支来管理代码。我的想法是粒度大一点，类似YYKit这种，弄一个全家桶，然后内部弄一些子pod库，然后项目直接引用这个全家桶，减少一些重复基建工作。一些前置条件大概的步骤，按以下几步进行 搭建一个公司内部的私有pod源 ✅ 项目进行梳理，拆分解耦基建组件库 ✅ 拉分支，集成私有库，删除旧源码 ❌ 测试，上线** ❌线上监控线上监控的一个思路，主要是对接bugly、钉钉、服务端。目前我们项目里面已经接入了bugly监控，所以线上的监控也可以应用bugly提供的数据内容进行hook，然后需要服务端提供一个接口。将bugly每天产生的数据，进行一个再处理，将我们关注的数据进行一个汇总。用钉钉机器人发送到对应的群里。 ### 动态化 目前的项目，还没有动态化的能力，这方面是否考虑接入RN或者其他动态化能力 如果接入的话，个人建议接入RN，今年RN底层架构有了一个大的升级，从之前的JSCore引擎升级Hermes，新引擎比老引擎通信性能有了3倍的提升，启动性能也有2倍的提升 [RN新架构介绍](https://time.geekbang.org/column/article/499434) 关于协同工程代码书写规范快成iOS代码规范 规范名称 说明 例子 命名规范 大驼峰规则与小驼峰原则 NameTextField(大驼峰),nameTextField(小驼峰) 项目命名 大驼峰 AoRiseProject Bundle Identifier 命名 反域名命名 com.jianlongkuaicheng.driver 类名 大驼峰命名。一般是：前缀 + 功能 + 类型 KC + Login + ViewController VC结构分区 代码结构分区 变量和方法 小驼峰 - (void)addTrailerWithParams:(NSMutableDictionary *)params{} 常量 宏：大写KC + 大驼峰 全局常量：工程前+缀全大写 #define KCUserAgeKey @“userAgeKey”extern const NSString KC_USER_AGE_KEY 参数名 小驼峰命名 - (instancetype)initWithFrame:(CGRect)frame myCarViewItemClickBlock:(myCarViewItemClickBlock)itemClick myCarViewSearchPlateBlock:(myCarViewSearchPlateBlock)searchPlate; 资源文件规范 用途_模块名_逻辑名称用途_模块名_颜色用途_逻辑名称用途_颜色 文件夹命名 实体文件夹,首字母要大写 Model，View，Controller，Tool，Other，Service 版本规范 采用A.B.C 三位数字命名 注释规范 方法注释 方法外部统一用option + command + / ，方法内部统一用//注释 模型注释 ///注释 分支规范 Merge规范 严格执行gitlab的merge request禁止feature之间进行merge操作merge顺序：feature-&gt;release-&gt;master-&gt;feature commit规范 原则：明确提交的版本/项目/改动点[哪个项目+哪个版本?+模块?]-ADD/MOD/FIX/DELETE：desc 语法检查c语言编程规范检查clang,使用Xcode开发iOS语法检查的Clang插件 链接器：符号是怎么绑定到地址上的？","link":"/2022/08/08/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"},{"title":"点点滴滴：HTTPS和HTTP的区别","text":"从iOS9开始，苹果官方开始要求，上线的APP需要对HTTPs协议进行支持，虽然我们可以通过在项目的plist文件中设置属性的方式，暂时绕开这条限制， 但是我个人认为还是有必要了解下，苹果为什么要这么做？ 先简单科普下HTTP与HTTPS分别代表什么，以及它们的区别到底是什么？ HTPPS和HTTP的概念HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。 超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。 HTTPS和HTTP的区别：1.HTTPS议需要到CA申请证书，一般免费证书很少，需要交费。HTTP是超文本传输协议，不需要证书2.端口号不同，HTTPS端口号是443，HTTP端口号是803.HTTPS要进行多次的身份验证，6/7的握手以达到数据安全，性能消耗较大，也即通信之前需要先确认身份，只有身份确认才会发送信息。 看完上面HTTPS和HTTP的不同之后，我们不难发现其实二者最根本的区别就是在HTTPS比HTTP多使用的SSL层，那SSL层又是什么东东呢？且看下面这张图公式：HTTP+SSL/TLS+TCP = HTTPS 那么SSL、TLS又是什么鬼呢？简单的立即SSL就是对传输的内容通过某种算法进行加密的一种协议，那TLS又是什么呢？TLS实际上是SSL的升级版，看下下面的换算公式：SSL 2.0SSL 3.0TLS 1.0 (SSL 3.1)TLS 1.1 (SSL 3.1)TLS 1.2 (SSL 3.1) 目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。 那么身为移动端开发工程师，面对如此大势所趋，我们能做什么呢？方法一：要求公司的服务端进行升级，至少支持到苹果要求的TLS1.2方法二：在info.plist中进行配置，使APP能够访问不支持HTTPS的服务器。如果让你的APP能够访问任意的Host地址那么可以这样配置（这是最省事也是最不安全的） 123NSAppTransportSecurity NSAllowsArbitraryLoads","link":"/2016/08/27/%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4%EF%BC%9AHTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"点点滴滴：NSLog一点说道","text":"今天的小结主要讲述在IOS开发中实现自定义的NSLog方法 1 为什么要对NSLog进行重定义？在开始这个知识点的讲解之前，首先说下，为什么要对NSLog宏进行重定义。在项目开发中，经常需要对程序进行调试。由于调试分布在项目的各种地方，当项目发布时，如果再将调试信息去掉，显示会消耗很大的人力，物力。幸好，强大的xcode给我们提供了一个非常方便的功能。在项目的Build Settings中给Apple LLVM Preprocessing中的 preprocessor macros下面的Debug添加一个调试宏DEBUG=1,记住在Release下面不要添加任何东西！添加这个东西的意思就是告诉编译器，在调试阶段，项目中进行了一个DEBUG的宏定义，但是Release阶段不定义。 2 如何对NSLog宏进行定义了12345#ifdef DEBUG#define NSLog(args...) ExtendNSLog(__FILE__,__LINE__,__PRETTY_FUNCTION__,args);#else#define NSLog(x...)#endif 下面来对上述宏进行解释，如果定义了DEBUG宏，那么就对NSLog(args…)进行重定义，如果没有定义，将NSLog(args…)设置为空，不做任何处理， 3 如何对定义的信息进行输出，并附带.文件名，打印行数，方法名.接下来对ExtendNSLog()进行解释12345678910111213141516171819202122 void ExtendNSLog(const char *file, int lineNumber, const char *functionName, NSString *format, ...){ // Type to hold information about variable arguments. va_list ap; // Initialize a variable argument list. va_start (ap, format); // NSLog only adds a newline to the end of the NSLog format if // one is not already there. // Here we are utilizing this feature of NSLog() if (![format hasSuffix: @&quot;\\n&quot;]) { format = [format stringByAppendingString: @&quot;\\n\\n⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯\\n\\n&quot;]; } NSString *body = [[NSString alloc] initWithFormat:format arguments:ap]; // End using variable argument list. va_end (ap); NSString *fileName = [[NSString stringWithUTF8String:file] lastPathComponent]; fprintf(stderr, &quot;[%s LINE:%d]%s:\\n%s&quot;, [fileName UTF8String],lineNumber, (functionName[0])=='-'?(&amp;functionName[1]):functionName, [body UTF8String]); } 下面来对上述代码进行解释 获取参数列表类 启动参数列表类和格式化字符串的关联 获取格式化字符串的实际输出文本 关闭参数列表类和格式化字符串的关联 调用C函数fprintf(),将打印信息输出。","link":"/2016/08/27/%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4%EF%BC%9ANSLog%E4%B8%80%E7%82%B9%E8%AF%B4%E9%81%93/"},{"title":"点点滴滴：NSScanner的用法小结","text":"NSScanner类是一个类簇的抽象父类,该类簇为一个从NSString对象扫描值的对象提供了程序接口。 NSScanner对象把NSString 对象的的字符解释和转化成 number和string 类型的值。在创建NSScanner对象的时候为它分配字符(string )，当你从NSScanner对象获取内容的时候，它会从头到尾遍历字符串(string)。由于类簇的属性， scanner对象并不是 NSScanner类的实例，而是它一个私有子类的实例。尽管scanner对象的类是私有的，但是它的接口是公开的（抽象父类已经声明）。 NSScanner 的原始方法是string和Configuring a Scanner方法下面列举的所有的方法。在 NSScanner 对象扫描字符串的时候，你可以通过设置属性charactersToBeSkipped忽略某些字符。在扫描字符串之前，那些位于忽略字符集中的字符将会被跳过。默认的忽略字符是空格和回车字符。可以通过[[scanner string] substringFromIndex:[scanner scanLocation]]获取未扫描的字符串。 创建 Scanner对象123+ scannerWithString:+ localizedScannerWithString:- initWithString: Designated Initializer scannerWithString，返回值是 扫描过aString字符串的NSScanner 对象，该方法通过调用initWithString设置扫描字符串;localizedScannerWithString,返回值是 通过用户默认的 locale方式扫描字符串的NSScanner 对象，该方法也是通过调用initWithString设置扫描字符串;initWithString，返回值是NSScanner 对象，该对象通过扫描aString完成初始化 获取Scanner对象字符串1string Property 设置scanner对象123456789scanLocation PropertycaseSensitive PropertycharactersToBeSkipped Propertylocale PropertyscanLocation,下次扫描开始的位置，如果该值超出了string的区域，将会引起NSRangeException,该属性在发生错误后重新扫描时非常有用。caseSensitive，是否区分字符串中大小写的标志。默认为NO，注意：该设置不会应用到被跳过的字符集。charactersToBeSkipped,在扫描时被跳过的字符集，默认是空白格和回车键。被跳过的字符集优先于扫描的字符集：例如一个scanner被跳过的字符集为空格，通过scanInt:去查找字符串中的整型数时，首先做的不是扫描，而是跳过空格，直到找到十进制数据或者其他的字符。在字符被扫描的时候，跳过功能就失效了。如果你扫描的字符和跳过的字符是一样的，结果将是未知的。被跳过的字符是一个唯一值，scanner不会将忽略大小写的功能应用于它，也不会用这些字符做一些组合，如果在扫描字符换的时候你想忽略全部的元音字符，就要这么做（比如：将字符集设置成“AEIOUaeiou”};locale,scanner 的locale对它从字符串中区分数值产生影响，它通过locale的十进制分隔符区分浮点型数据的整数和小数部分。一个没有locale的scanner用非定域值。新的scanner若没有设置locale，使用默认locale。 扫描字符串123456789101112131415161718192021222324252627282930- scanCharactersFromSet:intoString:- scanUpToCharactersFromSet:intoString:- scanDecimal:- scanDouble:- scanFloat:- scanHexDouble:- scanHexFloat:- scanHexInt:- scanHexLongLong:- scanInteger:- scanInt:- scanLongLong:- scanString:intoString:- scanUnsignedLongLong:- scanUpToString:intoString:atEnd PropertyscanCharactersFromSet:intoString:扫描字符串中和NSCharacterSet字符集中匹配的字符，是按字符单个匹配的，例如，NSCharacterSet字符集为@&quot;test123Dmo&quot;，scanner字符串为 @&quot; 123test12Demotest&quot;，那么字符串中所有的字符都在字符集中，所以指针指向的地址存储的内容为&quot;123test12Demotest&quot;scanUpToCharactersFromSet:intoString：扫描字符串直到遇到NSCharacterSet字符集的字符时停止，指针指向的地址存储的内容为遇到跳过字符集字符之前的内容scanString:intoString:从当前的扫描位置开始扫描，判断扫描字符串是否从当前位置能扫描到和传入字符串相同的一串字符，如果能扫描到就返回YES,指针指向的地址存储的就是这段字符串的内容。例如scanner的string内容为123abc678,传入的字符串内容为abc，如果当前的扫描位置为0，那么扫描不到，但是如果将扫描位置设置成3，就可以扫描到了。scanUpToString:intoString:从当前的扫描位置开始扫描，扫描到和传入的字符串相同字符串时，停止，指针指向的地址存储的是遇到传入字符串之前的内容。例如scanner的string内容为123abc678,传入的字符串内容为abc，存储的内容为123scanDecimal:扫描NSDecimal类型的值，有关NSDecimal类型的值更多的信息可以查看：NSDecimalNumberscanDouble :扫描双精度浮点型字符，溢出和非溢出都被认为合法的浮点型数据。在溢出的情况下scanner将会跳过所有的数字，所以新的扫描位置将会在整个浮点型数据的后面。double指针指向的地址存储的数据为扫描出的值，包括溢出时的HUGE_VAL或者 –HUGE_VAL，即未溢出时的0.0。scanFloat：扫描单精度浮点型字符，具体内容同scanDoublescanHexDouble: 扫描双精度的十六进制类型，溢出和非溢出都被认为合法的浮点型数据。在溢出的情况下scanner将会跳过所有的数字，所以新的扫描位置将会在整个浮点型数据的后面。double指针指向的地址存储的数据为扫描出的值，包括溢出时的HUGE_VAL或者 –HUGE_VAL，即未溢出时的0.0。数据接收时对应的格式为 %a 或%A ，双精度十六进制字符前面一定要加 0x或者 0X。scanHexInt 扫描十六进制无符整型，unsigned int指针指向的地址值为 扫描到的值，包含溢出时的UINT_MAX。scanHexLongLong 同scanHexDoublescanInt 扫描整型，溢出也被认为是有效的整型，int 指针指向的地址的值为扫描到的值，包含溢出时的INT_MAX或INT_MIN。scanInteger 同scanIntscanLongLong 扫描LongLong 型，溢出也被认为是有效的整型，LongLong指针指向的地址的值为扫描到的值，包含溢出时的LLONG_MAX 或 LLONG_MIN。 如何使用场景1：获取URL中的请求key和value。我们知道在iOS中，系统封装的URL会有一个属性叫做Query，如果是一个正确的URL会有类似的格式@”https://wwww.baidu.com/home.php?name=cheng&amp;age=19&amp;nickname=hehe&quot; 其中？后面的就是URL的Query，那么如何分别获取key和value呢？ 123456789101112131415161718192021void scannerStringDemo(){ NSURL *url = [NSURL URLWithString:@&quot;https://wwww.baidu.com/home.php?name=cheng&amp;age=19&amp;nickname=hehe&quot;]; NSScanner *scanner = [[NSScanner alloc]initWithString:url.query]; NSCharacterSet *delimiterSet = [NSCharacterSet characterSetWithCharactersInString:@&quot;&amp;&quot;]; NSMutableDictionary *paris = [@{} mutableCopy]; while (![scanner isAtEnd]) { NSString *pairString = nil; [scanner scanUpToCharactersFromSet:delimiterSet intoString:&amp;pairString]; [scanner scanCharactersFromSet:delimiterSet intoString:NULL]; NSRange range = [pairString rangeOfString:@&quot;=&quot;]; if (range.location != NSNotFound) { NSString *key = [pairString substringToIndex:range.location]; NSString *value = [pairString substringFromIndex:range.location + range.length]; [paris setObject:key forKey:@&quot;key&quot;]; [paris setObject:value forKey:@&quot;value&quot;]; } }} 场景2：判断当前的字符串是否是一个纯数字12345- (BOOL)isPureInt:(NSString*)string{ NSScanner* scan = [NSScanner scannerWithString:string]; int val; return[scan scanInt:&amp;val] &amp;&amp; [scan isAtEnd];} 场景3：判断TextField输入的字符串是不是需要的格式，这里要求是最多三位小数的数字12345678910111213141516171819202122232425262728293031323334353637383940414243+(BOOL)isValidAboutInputText:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string decimalNumber:(NSInteger)number{ NSScanner *scanner = [NSScanner scannerWithString:string]; NSCharacterSet *numbers; NSRange pointRange = [textField.text rangeOfString:@&quot;.&quot;]; if ( (pointRange.length &gt; 0) &amp;&amp; (pointRange.location &lt; range.location || pointRange.location &gt; range.location + range.length) ){ numbers = [NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789&quot;]; }else{ numbers = [NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789.&quot;]; } if ( [textField.text isEqualToString:@&quot;&quot;] &amp;&amp; [string isEqualToString:@&quot;.&quot;] ){ return NO; } short remain = number; //保留 number位小数 NSString *tempStr = [textField.text stringByAppendingString:string]; NSUInteger strlen = [tempStr length]; if(pointRange.length &gt; 0 &amp;&amp; pointRange.location &gt; 0){ //判断输入框内是否含有“.”。 if([string isEqualToString:@&quot;.&quot;]){ //当输入框内已经含有“.”时，如果再输入“.”则被视为无效。 return NO; } if(strlen &gt; 0 &amp;&amp; (strlen - pointRange.location) &gt; remain+1){ //当输入框内已经含有“.”，当字符串长度减去小数点前面的字符串长度大于需要要保留的小数点位数，则视当次输入无效。 return NO; } } NSRange zeroRange = [textField.text rangeOfString:@&quot;0&quot;]; if(zeroRange.length == 1 &amp;&amp; zeroRange.location == 0){ //判断输入框第一个字符是否为“0” if(![string isEqualToString:@&quot;0&quot;] &amp;&amp; ![string isEqualToString:@&quot;.&quot;] &amp;&amp; [textField.text length] == 1){ //当输入框只有一个字符并且字符为“0”时，再输入不为“0”或者“.”的字符时，则将此输入替换输入框的这唯一字符。 textField.text = string; return NO; }else{ if(pointRange.length == 0 &amp;&amp; pointRange.location &gt; 0){ //当输入框第一个字符为“0”时，并且没有“.”字符时，如果当此输入的字符为“0”，则视当此输入无效。 if([string isEqualToString:@&quot;0&quot;]){ return NO; } } } } NSString *buffer; if ( ![scanner scanCharactersFromSet:numbers intoString:&amp;buffer] &amp;&amp; ([string length] != 0) ){ return NO; }else{ return YES; }} 注意事项1[scanner scanCharactersFromSet:delimiterSet intoString:NULL];可以使用这个方法，跳过不需要的字符。 目前能想到的用法就这些，如果有更多的用法，以后慢慢补充！","link":"/2016/08/27/%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4%EF%BC%9ANSScanner%E7%9A%84%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"title":"点点滴滴：一个容易被忽视的数组和字典的方法","text":"今天来讨论下平时大家熟悉的数组/字典，但是容易忽略的数组/字典的valueForKeyPath方法可能大家对- (id)valueForKeyPath:(NSString *)keyPath方法不是很了解。其实这个方法非常的强大，举个例子: 12NSArray *array = @[@&quot;name&quot;, @&quot;w&quot;, @&quot;aa&quot;, @&quot;jimsa&quot;];NSLog(@&quot;%@&quot;, [array valueForKeyPath:@&quot;uppercaseString&quot;]); 输出( NAME, W, AA, JIMSA) 相当于数组中的每个成员执行了uppercaseString方法，然后把返回的对象组成一个新数组返回。既然可以用uppercaseString方法，那么NSString的其他方法也可以，比如 1[array valueForKeyPath:@&quot;length&quot;]; 返回每个字符串长度的组成的数组。只要你能想到的成员实例方法都可以这么用。如果你觉得这个方法就这么点功能，那就错了。还是举具体的例子对NSNumber数组快速计算数组求和、平均数、最大值、最小值 12345NSArray *array = @[@1, @2, @3, @4, @10]; NSNumber *sum = [array valueForKeyPath:@&quot;@sum.self&quot;]; NSNumber *avg = [array valueForKeyPath:@&quot;@avg.self&quot;]; NSNumber *max = [array valueForKeyPath:@&quot;@max.self&quot;]; NSNumber *min = [array valueForKeyPath:@&quot;@min.self&quot;]; 或者指定输出类型 12NSArray *array = @[@&quot;name&quot;, @&quot;w&quot;, @&quot;aa&quot;, @&quot;jimsa&quot;, @&quot;aa&quot;]; NSLog(@&quot;%@&quot;, [array valueForKeyPath:@&quot;@distinctUnionOfObjects.self&quot;]); 打印(name,w,jimsa,aa) 对NSDictionary数组快速找出相应key对的值 12345NSArray *array = @[@{@&quot;name&quot; : @&quot;cookeee&quot;,@&quot;code&quot; : @1}, @{@&quot;name&quot;: @&quot;jim&quot;,@&quot;code&quot; : @2}, @{@&quot;name&quot;: @&quot;jim&quot;,@&quot;code&quot; : @1}, @{@&quot;name&quot;: @&quot;jbos&quot;,@&quot;code&quot; : @1}];NSLog(@&quot;%@&quot;, [array valueForKeyPath:@&quot;name&quot;]); 直接得到字典中namekey对应的值组成的数组，显然比循环取值再加入到新数组中方便快捷( cookeee, jim, jim, jbos) 同样可以嵌套使用，先剔除name对应值的重复数据再取值 12345NSArray *array = @[@{@&quot;name&quot; : @&quot;cookeee&quot;,@&quot;code&quot; : @1}, @{@&quot;name&quot;: @&quot;jim&quot;,@&quot;code&quot; : @2}, @{@&quot;name&quot;: @&quot;jim&quot;,@&quot;code&quot; : @1}, @{@&quot;name&quot;: @&quot;jbos&quot;,@&quot;code&quot; : @1}]; NSLog(@&quot;%@&quot;, [array valueForKeyPath:@&quot;@distinctUnionOfObjects.name&quot;]); 打印(cookeee,jim,jbos)","link":"/2016/08/27/%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E8%A7%86%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E5%85%B8%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"点点滴滴：关于va_list","text":"想必在iOS这行混过一段时间的人看到下面的代码都会很熟悉 我们今天要讨论的就是这个方法最后边的可变参数列表的使用。这个方法内部到底是如何实现的呢？以及这样提供函数调用的好处又有哪些呢？接下来，我们慢慢研究下 1.首先，苹果这么做，肯定是有它这么设计的原因。相比于最后一个参数换为数组，可变参数列表的形式更加直观，可读性强！此外，相对于只能传递一个参数的方法，可变参数列表参数又提供了扩展性，基于此，很有必要去研究下可变参数列表的使用了。2.其次，iOS实现可变参数列表的关键点是什么？关键在于va_list。va_list是C语言提供的处理可变参数的一种方法。具体的注意事项如下 1.首先在函数里面定义va_list的变量，这个变量是指向参数的指针。2.然后用va_start初始化刚定义的va_list变量。3.然后用va_arg返回可变的参数，va_arg的第二个参数是返回的参数类型，例如va_arg(args,NSString *)，va_arg每调用一次就会指向下个参数的地址，直到再也没有获取到参数为止。4.最后用va_end宏结束可变参数的获取。 下面，用一个demo来具体演示下如果使用可变参数列表声明、定义函数 Tips 1.函数调用的时候，最后一个参数后面一定要加nil，我们也在函数声明的定义用编译器去做了属性声明，要求最后一个参数传递nil进去，否则会crash。2.函数传递的参数类型要求是相同数据类型，要传字符串都传字符串，要传数字都传数字，否则也会有问题。今天主要就对这个进行一个小小的总结，总结这个题材会做多少期，目前我个人也不知道，等哪天总结的差不多了，也许就停下来了吧。嘿嘿！","link":"/2016/08/27/%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4%EF%BC%9A%E5%85%B3%E4%BA%8Eva-list/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"ReactNative","slug":"ReactNative","link":"/tags/ReactNative/"},{"name":"RN","slug":"RN","link":"/tags/RN/"},{"name":"三方库研究","slug":"三方库研究","link":"/tags/%E4%B8%89%E6%96%B9%E5%BA%93%E7%A0%94%E7%A9%B6/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"翻译","slug":"翻译","link":"/tags/%E7%BF%BB%E8%AF%91/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"coredata学习","slug":"coredata学习","link":"/tags/coredata%E5%AD%A6%E4%B9%A0/"},{"name":"点点滴滴","slug":"点点滴滴","link":"/tags/%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4/"}],"categories":[{"name":"转","slug":"转","link":"/categories/%E8%BD%AC/"}],"pages":[{"title":"关于","text":"记录学习的点点滴滴","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}]}